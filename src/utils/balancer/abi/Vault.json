{
  "address": "0x47753454C4270DAE017499952b973c24Aaa5768D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IAuthorizer",
          "name": "authorizer",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "InternalBalanceDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "InternalBalanceTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "InternalBalanceWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "manager",
          "type": "address"
        }
      ],
      "name": "PoolAssetManagerSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "assetManager",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "amount",
          "type": "int256"
        }
      ],
      "name": "PoolBalanceChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "PoolCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "liquidityProvider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amountsOut",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "protocolFees",
          "type": "uint256[]"
        }
      ],
      "name": "PoolExited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "liquidityProvider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amountsIn",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "protocolFees",
          "type": "uint256[]"
        }
      ],
      "name": "PoolJoined",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC20",
          "name": "tokenOut",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokensIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokensOut",
          "type": "uint256"
        }
      ],
      "name": "Swap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "TokensRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "TokensUnregistered",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISwapValidator",
          "name": "validator",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "validatorData",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "tokenInIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenOutIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct IVault.SwapIn[]",
          "name": "swaps",
          "type": "tuple[]"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        }
      ],
      "name": "batchSwapGivenIn",
      "outputs": [
        {
          "internalType": "int256[]",
          "name": "",
          "type": "int256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ISwapValidator",
          "name": "validator",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "validatorData",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "tokenInIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenOutIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountOut",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct IVault.SwapOut[]",
          "name": "swaps",
          "type": "tuple[]"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        }
      ],
      "name": "batchSwapGivenOut",
      "outputs": [
        {
          "internalType": "int256[]",
          "name": "",
          "type": "int256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAuthorizer",
          "name": "newAuthorizer",
          "type": "address"
        }
      ],
      "name": "changeAuthorizer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "depositToInternalBalance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "depositToPoolBalance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "minAmountsOut",
          "type": "uint256[]"
        },
        {
          "internalType": "bool",
          "name": "toInternalBalance",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "userData",
          "type": "bytes"
        }
      ],
      "name": "exitPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IFlashLoanReceiver",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "receiverData",
          "type": "bytes"
        }
      ],
      "name": "flashLoan",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAuthorizer",
      "outputs": [
        {
          "internalType": "contract IAuthorizer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getCollectedFeesByToken",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "getInternalBalance",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getNumberOfPools",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "getPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "enum IVault.PoolSpecialization",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getPoolAssetManager",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "start",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "end",
          "type": "uint256"
        }
      ],
      "name": "getPoolIds",
      "outputs": [
        {
          "internalType": "bytes32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getPoolTokenBalanceInfo",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "cash",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "managed",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "getPoolTokens",
      "outputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "balances",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolFlashLoanFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolSwapFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getProtocolWithdrawFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "maxAmountsIn",
          "type": "uint256[]"
        },
        {
          "internalType": "bool",
          "name": "fromInternalBalance",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "userData",
          "type": "bytes"
        }
      ],
      "name": "joinPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "tokenInIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenOutIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct IVault.SwapIn[]",
          "name": "swaps",
          "type": "tuple[]"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        }
      ],
      "name": "queryBatchSwapGivenIn",
      "outputs": [
        {
          "internalType": "int256[]",
          "name": "",
          "type": "int256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "tokenInIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenOutIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amountOut",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct IVault.SwapOut[]",
          "name": "swaps",
          "type": "tuple[]"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        }
      ],
      "name": "queryBatchSwapGivenOut",
      "outputs": [
        {
          "internalType": "int256[]",
          "name": "",
          "type": "int256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "poolId",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "tokenInIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenOutIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Swaps.SwapInternal[]",
          "name": "swaps",
          "type": "tuple[]"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.FundManagement",
          "name": "funds",
          "type": "tuple"
        },
        {
          "internalType": "enum Swaps.SwapKind",
          "name": "kind",
          "type": "uint8"
        }
      ],
      "name": "queryBatchSwapHelper",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IVault.PoolSpecialization",
          "name": "specialization",
          "type": "uint8"
        }
      ],
      "name": "registerPool",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "address[]",
          "name": "assetManagers",
          "type": "address[]"
        }
      ],
      "name": "registerTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newFee",
          "type": "uint256"
        }
      ],
      "name": "setProtocolFlashLoanFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newFee",
          "type": "uint256"
        }
      ],
      "name": "setProtocolSwapFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newFee",
          "type": "uint256"
        }
      ],
      "name": "setProtocolWithdrawFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "transferInternalBalance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "name": "unregisterTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "updateManagedBalance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "withdrawFromInternalBalance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawFromPoolBalance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "tokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "withdrawProtocolFees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe014275e76918d5d09d5b87447ff13a3c12807a35bd2715d4abb3c2d0aa55a1a",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x0683B39C3a042fcEaf71De7CcF4bcD60898758dA",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "8471756",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xea823eab776c4b4ded054b577e2312e94d852f10c6a8dd694ef6878f09450f6f",
    "transactionHash": "0xe014275e76918d5d09d5b87447ff13a3c12807a35bd2715d4abb3c2d0aa55a1a",
    "logs": [],
    "blockNumber": 4,
    "cumulativeGasUsed": "8471756",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xec988e2EF97468a4501a8B676Cb5F51752C2C684"
  ],
  "solcInputHash": "bda5793225c06166b1ababd6dc2d5abe",
  "metadata": "{\"compiler\":{\"version\":\"0.7.1+commit.f4a555be\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"authorizer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InternalBalanceDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InternalBalanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InternalBalanceWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"PoolAssetManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"PoolBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"protocolFees\",\"type\":\"uint256[]\"}],\"name\":\"PoolExited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"protocolFees\",\"type\":\"uint256[]\"}],\"name\":\"PoolJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"TokensRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"TokensUnregistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract ISwapValidator\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"validatorData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.SwapIn[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"}],\"name\":\"batchSwapGivenIn\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapValidator\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"validatorData\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.SwapOut[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"}],\"name\":\"batchSwapGivenOut\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"newAuthorizer\",\"type\":\"address\"}],\"name\":\"changeAuthorizer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositToInternalBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToPoolBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IFlashLoanReceiver\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"receiverData\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorizer\",\"outputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getCollectedFeesByToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getInternalBalance\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"enum IVault.PoolSpecialization\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPoolAssetManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getPoolIds\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPoolTokenBalanceInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"getPoolTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFlashLoanFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.SwapIn[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"}],\"name\":\"queryBatchSwapGivenIn\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.SwapOut[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"}],\"name\":\"queryBatchSwapGivenOut\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct Swaps.SwapInternal[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"},{\"internalType\":\"enum Swaps.SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"}],\"name\":\"queryBatchSwapHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IVault.PoolSpecialization\",\"name\":\"specialization\",\"type\":\"uint8\"}],\"name\":\"registerPool\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"assetManagers\",\"type\":\"address[]\"}],\"name\":\"registerTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolFlashLoanFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolWithdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferInternalBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"unregisterTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateManagedBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawFromInternalBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromPoolBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"batchSwapGivenIn(address,bytes,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool))\":{\"details\":\"Performs a series of swaps with one or multiple Pools. In each swap, the amount of tokens sent to the Pool is known. For swaps where the amount of tokens received from the Pool is known, see `batchSwapGivenOut`. Returns an array with the net Vault token balance deltas. Positive amounts represent tokens sent to the Vault, and negative amounts tokens sent by the Vault. Each delta corresponds to the token at the same index in the `tokens` array. A `validator` can be optionally supplied, and if so it will be called with `tokens`, the Vault deltas, and user-supplied `validatorData`. This is useful to check a swap has happened according to user expectations (and wasn't, for example, affected by other transactions), and potentially revert if not. Each swap is executed independently in the order specified by the `swaps` array. However, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into the User's Internal Balance) after all swaps have been completed and the net token balance change computed. This means it is possible to e.g. under certain conditions perform arbitrage by swapping with multiple Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (but updating the Pool's internal balances). The `swaps` array contains the information about each individual swaps. All swaps consist of a Pool receiving some amount of one of its tokens (`tokenIn`), and sending some amount of another one of its tokens (`tokenOut`). The `tokenOut` amount is determined by the Pool's pricing algorithm by calling the `quoteOutGivenIn` function (from IGeneralPoolQuote or IMinimalSwapInfoPoolQuote). Multihop swaps, where one token is exchanged for another one by passing through one or more intermediate tokens, can be executed by passing an `amountIn` value of zero for a swap. This will cause the amount out of the previous swap to be used as the amount in of the current one. In such a scenario, `tokenIn` must equal the previous swap's `tokenOut`. The `tokens` array contains the addresses of all tokens involved in the swaps. Funds will be sent and  received according to the data in the `funds` struct.\"},\"batchSwapGivenOut(address,bytes,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool))\":{\"details\":\"Performs a series of swaps with one or multiple Pools. In each swap, the amount of tokens received from the Pool is known. For swaps where the amount of tokens sent to the Pool is known, see `batchSwapGivenIn`. Returns an array with the net Vault token balance deltas. Positive amounts represent tokens sent to the Vault, and negative amounts tokens sent by the Vault. Each delta corresponds to the token at the same index in the `tokens` array. A `validator` can be optionally supplied, and if so it will be called with `tokens`, the Vault deltas, and user-supplied `validatorData`. This is useful to check a swap has happened according to user expectations (and wasn't, for example, affected by other transactions), and potentially revert if not. Each swap is executed independently in the order specified by the `swaps` array. However, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into the User's Internal Balance) after all swaps have been completed and the net token balance change computed. This means it is possible to e.g. under certain conditions perform arbitrage by swapping with multiple Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (but updating the Pool's internal balances). The `swaps` array contains the information about each individual swaps. All swaps consist of a Pool receiving some amount of one of its tokens (`tokenIn`), and sending some amount of another one of its tokens (`tokenOut`). The `tokenIn` amount is determined by the Pool's pricing algorithm by calling the `quoteInGivenOut` function (from IGeneralPoolQuote or IMinimalSwapInfoPoolQuote). Multihop swaps, where one token is exchanged for another one by passing through one or more intermediate tokens, can be executed by passing an `amountOut` value of zero for a swap. This will cause the amount in of the previous swap to be used as the amount out of the current one. In such a scenario, `tokenOut` must equal the previous swap's `tokenIn`. The `tokens` array contains the addresses of all tokens involved in the swaps. Funds will be sent and  received according to the data in the `funds` struct.\"},\"changeAuthorizer(address)\":{\"details\":\"Sets a new Authorizer for the Vault. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canChangeAuthorizer`).\"},\"depositToInternalBalance(address[],uint256[],address)\":{\"details\":\"Deposits tokens from the caller into `user`'s Internal Balance. The caller must have allowed the Vault to use their tokens via `IERC20.approve()`.\"},\"depositToPoolBalance(bytes32,address,uint256)\":{\"details\":\"Called by a Pool's Asset Manager for `token` to deposit `amount` tokens into the Vault. This increases the Pool's cash but decreases its managed balance, leaving the total balance unchanged. The Asset Manager must have approved the Vault to use `token`.\"},\"flashLoan(address,address[],uint256[],bytes)\":{\"details\":\"Performs a flash loan where 'amount' tokens of 'token' are sent to 'receiver', which must implement the IFlashLoanReceiver interface. An arbitrary user-provided 'receiverData' is forwarded to this contract. Before returning from the IFlashLoanReceiver.receiveFlashLoan call, the receiver must transfer back the loaned tokens, plus a proportional protocol fee.\"},\"getAuthorizer()\":{\"details\":\"Returns the Vault's Authorizer.\"},\"getCollectedFeesByToken(address)\":{\"details\":\"Returns the amount of protocol fees collected by the Vault for `token`.\"},\"getInternalBalance(address,address[])\":{\"details\":\"Returns `user`'s Internal Balance for a specific token.\"},\"getNumberOfPools()\":{\"details\":\"Returns the number of Pools.\"},\"getPool(bytes32)\":{\"details\":\"Returns a Pool's address and specialization level.\"},\"getPoolAssetManager(bytes32,address)\":{\"details\":\"Returns a Pool's Asset Manager for `token`. Asset Managers can manage a Pool's assets by taking them out of the Vault via `withdrawFromPoolBalance`, `depositToPoolBalance` and `updateManagedBalance`.\"},\"getPoolIds(uint256,uint256)\":{\"details\":\"Returns a partial list of Pool IDs, starting at index `start`, up to index `end`.\"},\"getPoolTokenBalanceInfo(bytes32,address)\":{\"details\":\"Returns the Pool's token cash and managed balances.\"},\"getPoolTokens(bytes32)\":{\"details\":\"Returns the Pool's tokens and total balances. This means it will refer also to the assets held by the Pool's Asset Manager and not currently held by the Vault.\"},\"getProtocolFlashLoanFee()\":{\"details\":\"Returns the Protocol Flash Loan Fee. These are collected on all Flash Loans. This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee.\"},\"getProtocolSwapFee()\":{\"details\":\"Returns the Protocol Swap Fee. These are paid by Pools via `paySwapProtocolFees`. This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee.\"},\"getProtocolWithdrawFee()\":{\"details\":\"Returns the Protocol Withdraw Fee. Withdraw fees are applied on `withdraw` and `exitPool` (unless depositing into User's Internal Balance). Swaps and `withdrawFromPoolBalance` are not charged withdraw fees. This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee.\"},\"joinPool(bytes32,address,address[],uint256[],bool,bytes)\":{\"details\":\"Called by users to join a Pool, transferring tokens into its balance. The `IPool.onJoinPool` hook will be called on the Pool by the Vault, which will typically grant something to the user in return - often tokenized Pool shares. `maxAmountsIn` is the maximum amount of tokens the user is willing to provide to the Pool, for each token in the `tokens` array. This array must match the Pool's registered tokens. Pools are free to implement any arbitrary logic in the `IPool.onJoinPool` hook, and may require additional information (such as the expected number of Pool shares to obtain). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool, as is `recipient`. If `fromInternalBalance` is true, the caller's Internal Balance will be preferred, performing an ERC20 transfer for the difference between the requested amount and Internal Balance (if any).\"},\"queryBatchSwapGivenIn((bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool))\":{\"details\":\"Simulates a call to batchSwapGivenIn, returning an array of Vault token deltas. Each element in the array corresponds to the token at the same index, and indicates the number of tokens the Vault would take from the caller (if positive) or send to the recipient (if negative). The arguments it receives are the same that an equivalent batchSwapGivenIn would receive. Unlike batchSwapGivenIn, this function performs no checks on its caller nor the recipient field in the FundsManagement struct. This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens, approve them for the Vault, or even know a user's address. Note that this function is not 'view' (due to implementation details): the client code must explicitly execute eth_call instead of eth_sendTransaction.\"},\"queryBatchSwapGivenOut((bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool))\":{\"details\":\"Simulates a call to batchSwapGivenOut, returning an array of Vault token deltas. Each element in the array corresponds to the token at the same index, and indicates the number of tokens the Vault would take from the caller (if positive) or send to the recipient (if negative). The arguments it receives are the same that an equivalent batchSwapGivenOut would receive. Unlike batchSwapGivenOut, this function performs no checks on its caller nor the recipient field in the FundsManagement struct. This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens, approve them for the Vault, or even know a user's address. Note that this function is not 'view' (due to implementation details): the client code must explicitly execute eth_call instead of eth_sendTransaction.\"},\"queryBatchSwapHelper((bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool),uint8)\":{\"details\":\"Despite this function being external, it can only be called by the Vault itself, and should not be considered part of the Vault's external API. It executes the Pool interaction part of a batch swap, asking Pools for quotes and computing the Vault deltas, but without performing any token transfers. It then reverts unconditionally, returning the Vault deltas array as the revert data. This enables an accurate implementation of queryBatchSwapGivenIn and queryBatchSwapGivenOut, since the array 'returned' by this function is the result of the exact same computation a swap would perform, including the Pool calls.\"},\"registerPool(uint8)\":{\"details\":\"Registers a the caller as a Pool, with selected specialization level. Returns the Pool's ID. Also emits a PoolCreated event.\"},\"registerTokens(bytes32,address[],address[])\":{\"details\":\"Called by the Pool to register `tokens`. A Pool can only add and remove liquidity for tokens it has registered, and all swaps with a Pool must involve registered tokens. Each token in `tokens` must not be already registered before this call. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens must be registered at the same time. Also define the asset manager for each token at registration time (can be the zero address, if a token is unmanaged)\"},\"setProtocolFlashLoanFee(uint256)\":{\"details\":\"Sets a new Protocol Flash Loan Fee. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolFlashLoanFee`).\"},\"setProtocolSwapFee(uint256)\":{\"details\":\"Sets a new Protocol Swap Fee. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolSwapFee`).\"},\"setProtocolWithdrawFee(uint256)\":{\"details\":\"Sets a new Protocol Withdraw Fee. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolWithdrawFee`).\"},\"transferInternalBalance(address[],uint256[],address)\":{\"details\":\"Transfers tokens from the caller's Internal Balance, transferring them to `recipient`'s Internal Balance. This does not charge protocol withdrawal fees.\"},\"unregisterTokens(bytes32,address[])\":{\"details\":\"Called by the Pool to unregisted `tokens`. This prevents adding and removing liquidity in the future, as well as swaps. Unregistered tokens can be re-registered in the future. Each token in `tokens` must be registered before this call, and have zero balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens must be unregistered at the same time.\"},\"updateManagedBalance(bytes32,address,uint256)\":{\"details\":\"Called by a Pool's Asset Manager for `token` to update the external amount. This causes no change on the Pool's cash, but because the managed balance changes, so does the total balance. The external amount can be both increased and decreased by this call.\"},\"withdrawFromInternalBalance(address[],uint256[],address)\":{\"details\":\"Withdraws tokens from the caller's Internal Balance, transferring them to `recipient`. This charges protocol withdrawal fees.\"},\"withdrawFromPoolBalance(bytes32,address,uint256)\":{\"details\":\"Called by a Pool's Asset Manager for `token` to withdraw `amount` tokens from the Vault. This decreases the Pool's cash but increases its managed balance, leaving the total balance unchanged.\"},\"withdrawProtocolFees(address[],uint256[],address)\":{\"details\":\"Withdraws collected protocol fees. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canWithdrawProtocolFees`) for each token.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/vault/Vault.sol\":\"Vault\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":9999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\",\"keccak256\":\"0xa4fdec0ea7d943692cac780111ff2ff9d89848cad0494a59cfaed63a705054b4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xba96bc371ba999f452985a98717cca1e4c4abb598dc038a9a9c3db08129b1ba4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xba085261d44cf28d2583f7c8cdb2f0a6a495ff1a640f86d995ea9d36b42b0046\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbd74f587ab9b9711801baf667db1426e4a03fd2d7f15af33e0e0d0394e7cef76\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc77dd6233a82c7c6e3dc49da8f3456baa00ecd3ea4dfa9222002a9aebf155dcd\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x07779badf9435bce9a95e4527e892d83a2baae798ba87203db0b22679b40ef35\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\",\"keccak256\":\"0x7412b7c3acc6d3b2b6bad1dadc114e96daa3f82947d127f6184c84156720f88c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x79004a1d1471abe87e92c4497acba06d5dfa5b1f3e9894a0991a7c4669c5c02c\",\"license\":\"MIT\"},\"contracts/math/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint128 internal constant ONE = 10**18; // 18 decimal places\\n\\n    uint256 internal constant MIN_POW_BASE = 1 wei;\\n    uint256 internal constant MAX_POW_BASE = (2 * ONE) - 1 wei;\\n    uint256 internal constant POW_PRECISION = ONE / 10**10;\\n\\n    function btoi(uint256 a) internal pure returns (uint256) {\\n        return a / ONE;\\n    }\\n\\n    function floor(uint256 a) internal pure returns (uint256) {\\n        return btoi(a) * ONE;\\n    }\\n\\n    function abs(int256 a) internal pure returns (uint256) {\\n        if (a > 0) {\\n            return uint256(a);\\n        } else {\\n            return uint256(-a);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function add128(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (uint256 c, bool flag) = subSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function subSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function sub128(uint128 a, uint128 b) internal pure returns (uint128) {\\n        (uint128 c, bool flag) = subSign128(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function subSign128(uint128 a, uint128 b) internal pure returns (uint128, bool) {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint256 c1 = c0 + (ONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint256 c2 = c1 / ONE;\\n        return c2;\\n    }\\n\\n    function mul128(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint128 c1 = c0 + (ONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint128 c2 = c1 / ONE;\\n        return c2;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint256 c0 = a * ONE;\\n        require(a == 0 || c0 / a == ONE, \\\"ERR_DIV_INTERNAL\\\"); // mul overflow\\n        uint256 c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  add require\\n        uint256 c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    function div128(uint128 a, uint128 b) internal pure returns (uint128) {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint128 c0 = a * ONE;\\n        require(a == 0 || c0 / a == ONE, \\\"ERR_DIV_INTERNAL\\\"); // mul overflow\\n        uint128 c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  add require\\n        uint128 c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function powi(uint256 a, uint256 n) internal pure returns (uint256) {\\n        uint256 z = n % 2 != 0 ? a : ONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = mul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = mul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // credit for this implementation goes to\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) return 0;\\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\\n        // however that code costs significantly more gas\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\\n\",\"keccak256\":\"0x486091eb1440705160a9d9b8e98d7e4e69f38f429b89c6ecc448c09c65bdb90b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Authorization.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../vendor/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./interfaces/IVault.sol\\\";\\nimport \\\"./interfaces/IAuthorizer.sol\\\";\\n\\nabstract contract Authorization is IVault, ReentrancyGuard {\\n    IAuthorizer private _authorizer;\\n\\n    constructor(IAuthorizer authorizer) {\\n        _authorizer = authorizer;\\n    }\\n\\n    function getAuthorizer() public view override returns (IAuthorizer) {\\n        return _authorizer;\\n    }\\n\\n    function changeAuthorizer(IAuthorizer newAuthorizer) external override nonReentrant {\\n        require(_authorizer.canChangeAuthorizer(msg.sender), \\\"Caller cannot transfer authority\\\");\\n\\n        _authorizer = newAuthorizer;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8a964bcf96afcf51f6e0ab2a23a274f44f1bd56bd914845e28dfea536fa182\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Fees.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"../vendor/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../math/FixedPoint.sol\\\";\\n\\nimport \\\"./interfaces/IVault.sol\\\";\\nimport \\\"./Authorization.sol\\\";\\n\\nabstract contract Fees is IVault, ReentrancyGuard, Authorization {\\n    using SafeERC20 for IERC20;\\n    using SafeCast for uint256;\\n    using FixedPoint for uint256;\\n    using FixedPoint for uint128;\\n\\n    // Stores the fee collected per each token that is only withdrawable by the admin.\\n    mapping(IERC20 => uint256) internal _collectedProtocolFees;\\n\\n    // The withdraw fee is charged whenever tokens exit the vault (except in the case of swaps), and is a\\n    // percentage of the tokens exiting\\n    uint128 private _protocolWithdrawFee;\\n\\n    // The swap fee is charged whenever a swap occurs, and is a percentage of the fee charged by the Pool.\\n    // The Vault relies on the Pool being honest and reporting the actual fee it charged.\\n    uint128 private _protocolSwapFee;\\n\\n    // The flash loan fee is charged whenever a flash loan occurs, and is a percentage of the tokens lent\\n    uint256 private _protocolFlashLoanFee;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    uint128 private immutable _MAX_PROTOCOL_WITHDRAW_FEE = FixedPoint.ONE.mul128(2).div128(100); // 0.02 (2%)\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    uint128 private immutable _MAX_PROTOCOL_SWAP_FEE = FixedPoint.ONE.mul128(50).div128(100); // 0.5 (50%)\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    uint256 private immutable _MAX_PROTOCOL_FLASH_LOAN_FEE = FixedPoint.ONE.mul128(50).div128(100); // 0.5 (50%)\\n\\n    function getProtocolWithdrawFee() public view override returns (uint256) {\\n        return _protocolWithdrawFee;\\n    }\\n\\n    function _calculateProtocolWithdrawFeeAmount(uint128 amount) internal view returns (uint128) {\\n        return amount.mul128(_protocolWithdrawFee);\\n    }\\n\\n    function getProtocolSwapFee() public view override returns (uint256) {\\n        return _protocolSwapFee;\\n    }\\n\\n    function getProtocolFlashLoanFee() public view override returns (uint256) {\\n        return _protocolFlashLoanFee;\\n    }\\n\\n    function _calculateProtocolFlashLoanFeeAmount(uint256 swapFeeAmount) internal view returns (uint256) {\\n        return swapFeeAmount.mul(_protocolFlashLoanFee);\\n    }\\n\\n    function setProtocolWithdrawFee(uint256 newFee) external override nonReentrant {\\n        require(getAuthorizer().canSetProtocolWithdrawFee(msg.sender), \\\"Caller cannot set protocol withdraw fee\\\");\\n        require(newFee <= _MAX_PROTOCOL_WITHDRAW_FEE, \\\"Withdraw fee too high\\\");\\n\\n        _protocolWithdrawFee = newFee.toUint128();\\n    }\\n\\n    function setProtocolSwapFee(uint256 newFee) external override nonReentrant {\\n        require(getAuthorizer().canSetProtocolSwapFee(msg.sender), \\\"Caller cannot set protocol swap fee\\\");\\n        require(newFee <= _MAX_PROTOCOL_SWAP_FEE, \\\"Swap fee too high\\\");\\n\\n        _protocolSwapFee = newFee.toUint128();\\n    }\\n\\n    function setProtocolFlashLoanFee(uint256 newFee) external override nonReentrant {\\n        require(getAuthorizer().canSetProtocolFlashLoanFee(msg.sender), \\\"Caller cannot set protocol flash loan fee\\\");\\n        require(newFee <= _MAX_PROTOCOL_FLASH_LOAN_FEE, \\\"FlashLoan fee too high\\\");\\n\\n        _protocolFlashLoanFee = newFee.toUint128();\\n    }\\n\\n    function getCollectedFeesByToken(IERC20 token) external view override returns (uint256) {\\n        return _collectedProtocolFees[token];\\n    }\\n\\n    function withdrawProtocolFees(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external override nonReentrant {\\n        require(tokens.length == amounts.length, \\\"Tokens and amounts length mismatch\\\");\\n\\n        IAuthorizer authorizer = getAuthorizer();\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            require(authorizer.canWithdrawProtocolFees(msg.sender, token), \\\"Caller cannot withdraw protocol fees\\\");\\n\\n            uint256 amount = amounts[i];\\n            require(_collectedProtocolFees[token] >= amount, \\\"Insufficient protocol fees\\\");\\n            _collectedProtocolFees[token] -= amount;\\n            token.safeTransfer(recipient, amount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6518f1546dc4f205975d0168a8127de65246d7beb9978df8bfa8aa55bd4619f6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/FlashLoanProvider.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// This flash loan provider was based on the Aave protocol's open source\\n// implementation and terminology and interfaces are intentionally kept\\n// similar\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../vendor/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./interfaces/IFlashLoanReceiver.sol\\\";\\nimport \\\"./Fees.sol\\\";\\n\\nimport \\\"../math/FixedPoint.sol\\\";\\n\\nabstract contract FlashLoanProvider is ReentrancyGuard, Fees {\\n    using FixedPoint for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    function flashLoan(\\n        IFlashLoanReceiver receiver,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes calldata receiverData\\n    ) external override nonReentrant {\\n        require(tokens.length == amounts.length, \\\"Tokens and amounts length mismatch\\\");\\n\\n        uint256[] memory feeAmounts = new uint256[](tokens.length);\\n        uint256[] memory preLoanBalances = new uint256[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            preLoanBalances[i] = tokens[i].balanceOf(address(this));\\n            require(preLoanBalances[i] >= amounts[i], \\\"Insufficient balance to borrow\\\");\\n\\n            feeAmounts[i] = _calculateProtocolFlashLoanFeeAmount(amounts[i]);\\n\\n            tokens[i].safeTransfer(address(receiver), amounts[i]);\\n        }\\n\\n        receiver.receiveFlashLoan(tokens, amounts, feeAmounts, receiverData);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            uint256 postLoanBalance = tokens[i].balanceOf(address(this));\\n\\n            uint256 receivedFees = postLoanBalance.sub(preLoanBalances[i]);\\n            require(receivedFees >= feeAmounts[i], \\\"Insufficient protocol fees\\\");\\n\\n            _collectedProtocolFees[tokens[i]] = _collectedProtocolFees[tokens[i]].add(receivedFees);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24156efe28513fcbdfc784c6927986bab5432ece9f94d10426cc0504213e50c6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/InternalBalance.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"../vendor/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"./Fees.sol\\\";\\n\\nimport \\\"../math/FixedPoint.sol\\\";\\n\\nabstract contract InternalBalance is ReentrancyGuard, Fees {\\n    using SafeERC20 for IERC20;\\n    using FixedPoint for uint128;\\n    using FixedPoint for uint256;\\n    using SafeCast for uint256;\\n\\n    // user -> token -> internal balance\\n    mapping(address => mapping(IERC20 => uint128)) internal _internalTokenBalance;\\n\\n    event InternalBalanceDeposited(\\n        address indexed depositor,\\n        address indexed user,\\n        IERC20 indexed token,\\n        uint256 amount\\n    );\\n\\n    event InternalBalanceWithdrawn(\\n        address indexed user,\\n        address indexed recipient,\\n        IERC20 indexed token,\\n        uint256 amount\\n    );\\n\\n    event InternalBalanceTransferred(address indexed from, address indexed to, IERC20 indexed token, uint256 amount);\\n\\n    function getInternalBalance(address user, IERC20[] memory tokens)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory balances = new uint256[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            balances[i] = _internalTokenBalance[user][tokens[i]];\\n        }\\n\\n        return balances;\\n    }\\n\\n    function depositToInternalBalance(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        address user\\n    ) external override nonReentrant {\\n        require(tokens.length == amounts.length, \\\"Vault: tokens and amounts length mismatch\\\");\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            // memoize to save gas\\n            IERC20 token = tokens[i];\\n            uint256 amount = amounts[i];\\n\\n            _internalTokenBalance[user][token] = _internalTokenBalance[user][token].add128(amount.toUint128());\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n\\n            emit InternalBalanceDeposited(msg.sender, user, token, amount);\\n        }\\n    }\\n\\n    function withdrawFromInternalBalance(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        address recipient\\n    ) external override nonReentrant {\\n        require(tokens.length == amounts.length, \\\"Vault: tokens and amounts length mismatch\\\");\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            // memoize to save gas\\n            IERC20 token = tokens[i];\\n            uint128 amount = amounts[i].toUint128();\\n            uint128 initialBalance = _internalTokenBalance[msg.sender][token];\\n\\n            require(initialBalance >= amount, \\\"Vault: withdraw amount exceeds balance\\\");\\n\\n            _internalTokenBalance[msg.sender][token] = initialBalance - amount;\\n\\n            uint128 feeAmount = _calculateProtocolWithdrawFeeAmount(amount);\\n\\n            _collectedProtocolFees[token] = _collectedProtocolFees[token].add(feeAmount);\\n            token.safeTransfer(recipient, amount.sub(feeAmount));\\n\\n            emit InternalBalanceWithdrawn(msg.sender, recipient, token, amount);\\n        }\\n    }\\n\\n    function transferInternalBalance(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        address recipient\\n    ) external override nonReentrant {\\n        require(tokens.length == amounts.length, \\\"Vault: tokens and amounts length mismatch\\\");\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            IERC20 token = tokens[i];\\n            uint128 currentBalance = _internalTokenBalance[msg.sender][token];\\n            uint128 amount = amounts[i].toUint128();\\n\\n            require(amount <= currentBalance, \\\"ERR_NOT_ENOUGH_INTERNAL_BALANCE\\\");\\n\\n            _internalTokenBalance[msg.sender][token] = currentBalance - amount;\\n            _internalTokenBalance[recipient][token] = _internalTokenBalance[recipient][token].add128(amount);\\n\\n            emit InternalBalanceTransferred(msg.sender, recipient, token, amount);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3576ced8d71f466eafc1174573f8e6589efbdeaa02193b983a33b906ea9ae3b9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/PoolRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"../vendor/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./InternalBalance.sol\\\";\\n\\nimport \\\"./interfaces/IPool.sol\\\";\\n\\nimport \\\"./balances/BalanceAllocation.sol\\\";\\nimport \\\"./balances/GeneralPoolsBalance.sol\\\";\\nimport \\\"./balances/MinimalSwapInfoPoolsBalance.sol\\\";\\nimport \\\"./balances/TwoTokenPoolsBalance.sol\\\";\\n\\nabstract contract PoolRegistry is\\n    ReentrancyGuard,\\n    InternalBalance,\\n    GeneralPoolsBalance,\\n    MinimalSwapInfoPoolsBalance,\\n    TwoTokenPoolsBalance\\n{\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using SafeERC20 for IERC20;\\n    using BalanceAllocation for bytes32;\\n    using FixedPoint for uint128;\\n    using FixedPoint for uint256;\\n    using FixedPoint for int256;\\n    using SafeCast for uint256;\\n    using SafeCast for uint128;\\n\\n    // Set with all Pools in the system\\n    EnumerableSet.Bytes32Set internal _pools;\\n\\n    modifier withExistingPool(bytes32 poolId) {\\n        _ensureExistingPool(poolId);\\n        _;\\n    }\\n\\n    mapping(bytes32 => mapping(IERC20 => address)) private _poolAssetManagers;\\n\\n    event PoolAssetManagerSet(bytes32 indexed poolId, IERC20 indexed token, address indexed manager);\\n    event PoolBalanceChanged(bytes32 indexed poolId, address indexed assetManager, IERC20 indexed token, int256 amount);\\n\\n    modifier onlyPool(bytes32 poolId) {\\n        _ensurePoolIsSender(poolId);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns a Pool ID. These are deterministically created, by packing into the ID the Pool address and its\\n     * specialization setting. In order to make them unique, a nonce is also added.\\n     */\\n    function _toPoolId(\\n        address pool,\\n        PoolSpecialization specialization,\\n        uint80 nonce\\n    ) internal pure returns (bytes32) {\\n        uint256 serialized;\\n\\n        // | 20 bytes pool address | 2 bytes specialization setting | 10 bytes nonce |\\n        serialized |= uint256(nonce);\\n        serialized |= uint256(specialization) << (10 * 8);\\n        serialized |= uint256(pool) << (12 * 8);\\n\\n        return bytes32(serialized);\\n    }\\n\\n    /**\\n     * @dev Returns a Pool's address. Due to how Pool IDs are created, this is done with no storage\\n     * accesses and costs little gas.\\n     */\\n    function _getPoolAddress(bytes32 poolId) internal pure returns (address) {\\n        // | 20 bytes pool address | 2 bytes specialization setting | 10 bytes nonce |\\n        return address((uint256(poolId) >> (12 * 8)) & (2**(20 * 8) - 1));\\n    }\\n\\n    /**\\n     * @dev Returns a Pool's specialization setting. Due to how Pool IDs are created, this is done with no storage\\n     * accesses and costs little gas.\\n     */\\n    function _getPoolSpecialization(bytes32 poolId) internal pure returns (PoolSpecialization) {\\n        // | 20 bytes pool address | 2 bytes specialization setting | 10 bytes nonce |\\n        return PoolSpecialization(uint256(poolId >> (10 * 8)) & (2**(2 * 8) - 1));\\n    }\\n\\n    function registerPool(PoolSpecialization specialization) external override nonReentrant returns (bytes32) {\\n        // We use the Pool length as the Pool ID creation nonce. Since Pools cannot be deleted, nonces are unique. This\\n        // however assumes there will never be more than than 2**80 Pools.\\n        bytes32 poolId = _toPoolId(msg.sender, specialization, uint80(_pools.length()));\\n\\n        bool added = _pools.add(poolId);\\n        require(added, \\\"Pool ID already exists\\\");\\n\\n        emit PoolCreated(poolId);\\n\\n        return poolId;\\n    }\\n\\n    function getNumberOfPools() external view override returns (uint256) {\\n        return _pools.length();\\n    }\\n\\n    function getPoolIds(uint256 start, uint256 end) external view override returns (bytes32[] memory) {\\n        require((end >= start) && (end - start) <= _pools.length(), \\\"ERR_BAD_INDICES\\\");\\n\\n        bytes32[] memory poolIds = new bytes32[](end - start);\\n        for (uint256 i = 0; i < poolIds.length; ++i) {\\n            poolIds[i] = _pools.at(i + start);\\n        }\\n\\n        return poolIds;\\n    }\\n\\n    function getPoolTokens(bytes32 poolId)\\n        public\\n        view\\n        override\\n        withExistingPool(poolId)\\n        returns (IERC20[] memory tokens, uint256[] memory balances)\\n    {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            return _getTwoTokenPoolTokens(poolId);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            return _getMinimalSwapInfoPoolTokens(poolId);\\n        } else {\\n            return _getGeneralPoolTokens(poolId);\\n        }\\n    }\\n\\n    function getPoolTokenBalanceInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        override\\n        withExistingPool(poolId)\\n        returns (uint256 cash, uint256 managed)\\n    {\\n        bytes32 balance;\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            balance = _getTwoTokenPoolBalance(poolId, token);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            balance = _getMinimalSwapInfoPoolBalance(poolId, token);\\n        } else {\\n            balance = _getGeneralPoolBalance(poolId, token);\\n        }\\n\\n        cash = balance.cashBalance();\\n        managed = balance.managedBalance();\\n    }\\n\\n    function getPool(bytes32 poolId)\\n        external\\n        view\\n        override\\n        withExistingPool(poolId)\\n        returns (address, PoolSpecialization)\\n    {\\n        return (_getPoolAddress(poolId), _getPoolSpecialization(poolId));\\n    }\\n\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] calldata tokens,\\n        address[] calldata assetManagers\\n    ) external override nonReentrant onlyPool(poolId) {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            require(tokens.length == 2, \\\"ERR_TOKENS_LENGTH_MUST_BE_2\\\");\\n            _registerTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _registerMinimalSwapInfoPoolTokens(poolId, tokens);\\n        } else {\\n            _registerGeneralPoolTokens(poolId, tokens);\\n        }\\n\\n        // Assign each token's asset manager\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            address assetManager = assetManagers[i];\\n            IERC20 token = tokens[i];\\n\\n            // The asset manager feature is disabled by setting it to the zero address\\n            _poolAssetManagers[poolId][token] = assetManager;\\n            emit PoolAssetManagerSet(poolId, token, assetManager);\\n        }\\n\\n        emit TokensRegistered(poolId, tokens);\\n    }\\n\\n    function unregisterTokens(bytes32 poolId, IERC20[] calldata tokens)\\n        external\\n        override\\n        nonReentrant\\n        onlyPool(poolId)\\n    {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            require(tokens.length == 2, \\\"ERR_TOKENS_LENGTH_MUST_BE_2\\\");\\n            _unregisterTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _unregisterMinimalSwapInfoPoolTokens(poolId, tokens);\\n        } else {\\n            _unregisterGeneralPoolTokens(poolId, tokens);\\n        }\\n\\n        // The unregister calls above ensure the token balance is zero\\n        // So safe to remove any associated asset managers\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            delete _poolAssetManagers[poolId][tokens[i]];\\n        }\\n\\n        emit TokensUnregistered(poolId, tokens);\\n    }\\n\\n    function joinPool(\\n        bytes32 poolId,\\n        address recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory maxAmountsIn,\\n        bool fromInternalBalance,\\n        bytes memory userData\\n    ) external override nonReentrant withExistingPool(poolId) {\\n        require(tokens.length == maxAmountsIn.length, \\\"ERR_TOKENS_AMOUNTS_LENGTH_MISMATCH\\\");\\n        uint256[] memory balances = _validateTokensAndGetBalances(poolId, tokens);\\n\\n        (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _callOnJoinPool(\\n            poolId,\\n            tokens,\\n            balances,\\n            recipient,\\n            maxAmountsIn,\\n            userData\\n        );\\n\\n        // Signed because the fees might be larger than the amounts in for a token\\n        int256[] memory poolBalanceDeltas = new int256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            uint128 amountIn = amountsIn[i].toUint128();\\n            require(amountIn <= maxAmountsIn[i], \\\"ERR_JOIN_ABOVE_MAX\\\");\\n\\n            // Receive token\\n            _receiveTokens(token, amountIn, msg.sender, fromInternalBalance);\\n\\n            // Charge swap protocol fees to pool\\n            uint128 feeToPay = dueProtocolFeeAmounts[i].toUint128();\\n            _collectedProtocolFees[token] = _collectedProtocolFees[token].add(feeToPay);\\n            poolBalanceDeltas[i] = SignedSafeMath.sub(amountIn, feeToPay);\\n        }\\n\\n        // Grant tokens to pools - how this is done depends on the Pool specialization setting\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _alterTwoTokenPoolCash(poolId, tokens[0], poolBalanceDeltas[0], tokens[1], poolBalanceDeltas[1]);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _alterMinimalSwapInfoPoolCash(poolId, tokens, poolBalanceDeltas);\\n        } else {\\n            _alterGeneralPoolCash(poolId, tokens, poolBalanceDeltas);\\n        }\\n        emit PoolJoined(poolId, msg.sender, amountsIn, dueProtocolFeeAmounts);\\n    }\\n\\n    function exitPool(\\n        bytes32 poolId,\\n        address recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory minAmountsOut,\\n        bool toInternalBalance,\\n        bytes memory userData\\n    ) external override nonReentrant withExistingPool(poolId) {\\n        require(tokens.length == minAmountsOut.length, \\\"ERR_TOKENS_AMOUNTS_LENGTH_MISMATCH\\\");\\n\\n        uint256[] memory balances = _validateTokensAndGetBalances(poolId, tokens);\\n        (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _callOnExitPool(\\n            poolId,\\n            tokens,\\n            balances,\\n            recipient,\\n            minAmountsOut,\\n            userData\\n        );\\n\\n        uint256[] memory poolBalanceDeltas = new uint256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            uint128 amountOut = amountsOut[i].toUint128();\\n            require(amountOut >= minAmountsOut[i], \\\"ERR_EXIT_BELOW_MIN\\\");\\n\\n            // Send token\\n            _sendTokens(token, amountOut, recipient, toInternalBalance);\\n\\n            // Charge swap protocol fees to pool\\n            uint128 feeToPay = dueProtocolFeeAmounts[i].toUint128();\\n            _collectedProtocolFees[token] = _collectedProtocolFees[token].add(feeToPay);\\n            poolBalanceDeltas[i] = amountOut.add(feeToPay);\\n        }\\n\\n        // Grant tokens to pools - how this is done depends on the Pool specialization setting\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _decreaseTwoTokenPoolCash(\\n                poolId,\\n                tokens[0],\\n                poolBalanceDeltas[0].toUint128(),\\n                tokens[1],\\n                poolBalanceDeltas[1].toUint128()\\n            );\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _decreaseMinimalSwapInfoPoolCash(poolId, tokens, poolBalanceDeltas);\\n        } else {\\n            _decreaseGeneralPoolCash(poolId, tokens, poolBalanceDeltas);\\n        }\\n\\n        emit PoolExited(poolId, msg.sender, amountsOut, dueProtocolFeeAmounts);\\n    }\\n\\n    function _receiveTokens(\\n        IERC20 token,\\n        uint128 amount,\\n        address sender,\\n        bool fromInternalBalance\\n    ) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        uint128 tokensToReceive = amount;\\n        if (fromInternalBalance) {\\n            uint128 currentInternalBalance = _internalTokenBalance[sender][token];\\n            uint128 toWithdraw = Math.min(currentInternalBalance, tokensToReceive).toUint128();\\n\\n            // toWithdraw is guaranteed to be less or equal than both of these two amounts because it equals\\n            // the smallest of the two, which means the subtraction cannot overflow.\\n            _internalTokenBalance[sender][token] = currentInternalBalance - toWithdraw;\\n            tokensToReceive -= toWithdraw;\\n        }\\n\\n        if (tokensToReceive > 0) {\\n            token.safeTransferFrom(sender, address(this), tokensToReceive);\\n        }\\n    }\\n\\n    function _sendTokens(\\n        IERC20 token,\\n        uint128 amount,\\n        address recipient,\\n        bool toInternalBalance\\n    ) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        if (toInternalBalance) {\\n            // Deposit tokens to the recipient's Internal Balance - the Vault's balance doesn't change\\n            _internalTokenBalance[recipient][token] = _internalTokenBalance[recipient][token].add128(amount);\\n        } else {\\n            // Transfer the tokens to the recipient, charging the protocol exit fee\\n            uint128 feeAmount = _calculateProtocolWithdrawFeeAmount(amount);\\n            _collectedProtocolFees[token] = _collectedProtocolFees[token].add(feeAmount);\\n            token.safeTransfer(recipient, amount.sub(feeAmount));\\n        }\\n    }\\n\\n    function _callOnJoinPool(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        uint256[] memory balances,\\n        address recipient,\\n        uint256[] memory maxAmountsIn,\\n        bytes memory userData\\n    ) private returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) {\\n        address pool = _getPoolAddress(poolId);\\n        (amountsIn, dueProtocolFeeAmounts) = IPool(pool).onJoinPool(\\n            poolId,\\n            msg.sender,\\n            recipient,\\n            balances,\\n            maxAmountsIn,\\n            getProtocolSwapFee(),\\n            userData\\n        );\\n\\n        require(amountsIn.length == tokens.length, \\\"ERR_AMOUNTS_IN_LENGTH\\\");\\n        require(dueProtocolFeeAmounts.length == tokens.length, \\\"ERR_DUE_PROTOCOL_FEE_AMOUNTS_LENGTH\\\");\\n    }\\n\\n    function _callOnExitPool(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        uint256[] memory balances,\\n        address recipient,\\n        uint256[] memory minAmountsOut,\\n        bytes memory userData\\n    ) private returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) {\\n        address pool = _getPoolAddress(poolId);\\n        (amountsOut, dueProtocolFeeAmounts) = IPool(pool).onExitPool(\\n            poolId,\\n            msg.sender,\\n            recipient,\\n            balances,\\n            minAmountsOut,\\n            getProtocolSwapFee(),\\n            userData\\n        );\\n\\n        require(amountsOut.length == tokens.length, \\\"ERR_AMOUNTS_OUT_LENGTH\\\");\\n        require(dueProtocolFeeAmounts.length == tokens.length, \\\"ERR_DUE_PROTOCOL_FEE_AMOUNTS_LENGTH\\\");\\n    }\\n\\n    /**\\n     * @dev Require tokens are the same as the pool tokens, in the same order and complete\\n     */\\n    function _validateTokensAndGetBalances(bytes32 poolId, IERC20[] memory expectedTokens)\\n        internal\\n        view\\n        returns (uint256[] memory)\\n    {\\n        (IERC20[] memory actualTokens, uint256[] memory balances) = getPoolTokens(poolId);\\n        require(actualTokens.length == expectedTokens.length, \\\"ERR_TOKENS_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < actualTokens.length; ++i) {\\n            require(actualTokens[i] == expectedTokens[i], \\\"ERR_TOKENS_MISMATCH\\\");\\n        }\\n\\n        return balances;\\n    }\\n\\n    // Assets under management\\n\\n    modifier onlyPoolAssetManager(bytes32 poolId, IERC20 token) {\\n        _ensurePoolAssetManagerIsSender(poolId, token);\\n        _;\\n    }\\n\\n    function getPoolAssetManager(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        override\\n        withExistingPool(poolId)\\n        returns (address)\\n    {\\n        _ensureTokenRegistered(poolId, token);\\n        return _poolAssetManagers[poolId][token];\\n    }\\n\\n    function withdrawFromPoolBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) external override nonReentrant onlyPoolAssetManager(poolId, token) {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _minimalSwapInfoPoolCashToManaged(poolId, token, amount.toUint128());\\n        } else if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _twoTokenPoolCashToManaged(poolId, token, amount.toUint128());\\n        } else {\\n            _generalPoolCashToManaged(poolId, token, amount.toUint128());\\n        }\\n\\n        token.safeTransfer(msg.sender, amount);\\n        emit PoolBalanceChanged(poolId, msg.sender, token, amount.toInt256());\\n    }\\n\\n    function depositToPoolBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) external override nonReentrant onlyPoolAssetManager(poolId, token) {\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _minimalSwapInfoPoolManagedToCash(poolId, token, amount.toUint128());\\n        } else if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _twoTokenPoolManagedToCash(poolId, token, amount.toUint128());\\n        } else {\\n            _generalPoolManagedToCash(poolId, token, amount.toUint128());\\n        }\\n        emit PoolBalanceChanged(poolId, msg.sender, token, -(amount.toInt256()));\\n    }\\n\\n    function updateManagedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) external override nonReentrant onlyPoolAssetManager(poolId, token) {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            _setMinimalSwapInfoPoolManagedBalance(poolId, token, amount.toUint128());\\n        } else if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            _setTwoTokenPoolManagedBalance(poolId, token, amount.toUint128());\\n        } else {\\n            _setGeneralPoolManagedBalance(poolId, token, amount.toUint128());\\n        }\\n    }\\n\\n    function _ensurePoolIsSender(bytes32 poolId) internal view {\\n        _ensureExistingPool(poolId);\\n        address pool = _getPoolAddress(poolId);\\n        require(pool == msg.sender, \\\"Caller is not the pool\\\");\\n    }\\n\\n    function _ensureExistingPool(bytes32 poolId) internal view {\\n        require(_pools.contains(poolId), \\\"Nonexistent pool\\\");\\n    }\\n\\n    function _ensureTokenRegistered(bytes32 poolId, IERC20 token) internal view {\\n        require(_isTokenRegistered(poolId, token), \\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n    }\\n\\n    function _ensurePoolAssetManagerIsSender(bytes32 poolId, IERC20 token) internal view {\\n        _ensureExistingPool(poolId);\\n        _ensureTokenRegistered(poolId, token);\\n        require(_poolAssetManagers[poolId][token] == msg.sender, \\\"SENDER_NOT_ASSET_MANAGER\\\");\\n    }\\n\\n    function _isTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            return _isTwoTokenPoolTokenRegistered(poolId, token);\\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            return _isMinimalSwapInfoPoolTokenRegistered(poolId, token);\\n        } else {\\n            return _isGeneralPoolTokenRegistered(poolId, token);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfd8f4f3bed7102cd8ce86bee69f2b26be87c01484414008e5852baee5fb33800\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Swaps.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"../vendor/EnumerableMap.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"../vendor/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\nimport \\\"./interfaces/IPoolQuoteStructs.sol\\\";\\nimport \\\"./interfaces/IGeneralPoolQuote.sol\\\";\\nimport \\\"./interfaces/IMinimalSwapInfoPoolQuote.sol\\\";\\nimport \\\"./interfaces/ISwapValidator.sol\\\";\\nimport \\\"./balances/BalanceAllocation.sol\\\";\\n\\nimport \\\"../math/FixedPoint.sol\\\";\\n\\nimport \\\"./PoolRegistry.sol\\\";\\n\\nabstract contract Swaps is ReentrancyGuard, PoolRegistry {\\n    using SafeERC20 for IERC20;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableMap for EnumerableMap.IERC20ToBytes32Map;\\n\\n    using BalanceAllocation for bytes32;\\n    using FixedPoint for int256;\\n    using FixedPoint for uint256;\\n    using FixedPoint for uint128;\\n    using SafeCast for uint256;\\n    using SafeCast for uint128;\\n\\n    // Despite the external API having two separate functions for given in and given out, internally their are handled\\n    // together to avoid unnecessary code duplication. This enum indicates which kind of swap we're processing.\\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n    // This struct is identical in layout to SwapIn and SwapOut, except the 'amountIn/Out' field is named 'amount'.\\n    struct SwapInternal {\\n        bytes32 poolId;\\n        uint256 tokenInIndex;\\n        uint256 tokenOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    event Swap(\\n        bytes32 indexed poolId,\\n        IERC20 indexed tokenIn,\\n        IERC20 indexed tokenOut,\\n        uint256 tokensIn,\\n        uint256 tokensOut\\n    );\\n\\n    // This function is not marked non-reentrant to allow the validator to perform any subsequent calls it may need, but\\n    // the actual swap is reentrancy-protected by _batchSwap being non-reentrant.\\n\\n    function batchSwapGivenIn(\\n        ISwapValidator validator,\\n        bytes calldata validatorData,\\n        SwapIn[] memory swaps,\\n        IERC20[] calldata tokens,\\n        FundManagement calldata funds\\n    ) external override returns (int256[] memory) {\\n        int256[] memory tokenDeltas = _batchSwap(_toInternalSwap(swaps), tokens, funds, SwapKind.GIVEN_IN);\\n\\n        if (address(validator) != address(0)) {\\n            validator.validate(tokens, tokenDeltas, validatorData);\\n        }\\n\\n        return tokenDeltas;\\n    }\\n\\n    // This function is not marked non-reentrant to allow the validator to perform any subsequent calls it may need, but\\n    // the actual swap is reentrancy-protected by _batchSwap being non-reentrant.\\n    function batchSwapGivenOut(\\n        ISwapValidator validator,\\n        bytes calldata validatorData,\\n        SwapOut[] memory swaps,\\n        IERC20[] calldata tokens,\\n        FundManagement calldata funds\\n    ) external override returns (int256[] memory) {\\n        int256[] memory tokenDeltas = _batchSwap(_toInternalSwap(swaps), tokens, funds, SwapKind.GIVEN_OUT);\\n\\n        if (address(validator) != address(0)) {\\n            validator.validate(tokens, tokenDeltas, validatorData);\\n        }\\n\\n        return tokenDeltas;\\n    }\\n\\n    // We use inline assembly to cast from the external struct types to the internal one. This doesn't trigger any\\n    // conversions or runtime analysis: it is just coercing the type system to reinterpret the data as another type.\\n\\n    function _toInternalSwap(SwapIn[] memory swapsIn) private pure returns (SwapInternal[] memory swapsInternal) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            swapsInternal := swapsIn\\n        }\\n    }\\n\\n    function _toInternalSwap(SwapOut[] memory swapsOut) private pure returns (SwapInternal[] memory swapsInternal) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            swapsInternal := swapsOut\\n        }\\n    }\\n\\n    // This struct is identical in layout to QuoteRequestGivenIn and QuoteRequestGivenIn from IPoolQuoteStructs, except\\n    // the 'amountIn/Out' is named 'amount'.\\n    struct QuoteRequestInternal {\\n        IERC20 tokenIn;\\n        IERC20 tokenOut;\\n        uint256 amount;\\n        bytes32 poolId;\\n        address from;\\n        address to;\\n        bytes userData;\\n    }\\n\\n    // We use inline assembly to cast from the internal struct type to the external ones, depending on the swap kind.\\n    // This doesn't trigger any conversions or runtime analysis: it is just coercing the type system to reinterpret the\\n    // data as another type.\\n\\n    function _toQuoteGivenIn(QuoteRequestInternal memory requestInternal)\\n        private\\n        pure\\n        returns (IPoolQuoteStructs.QuoteRequestGivenIn memory requestGivenIn)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            requestGivenIn := requestInternal\\n        }\\n    }\\n\\n    function _toQuoteGivenOut(QuoteRequestInternal memory requestInternal)\\n        private\\n        pure\\n        returns (IPoolQuoteStructs.QuoteRequestGivenOut memory requestGivenOut)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            requestGivenOut := requestInternal\\n        }\\n    }\\n\\n    /**\\n     * @dev Implements both `batchSwapGivenIn` and `batchSwapGivenIn` (minus the validator call), depending on the\\n     * `kind` value.\\n     */\\n    function _batchSwap(\\n        SwapInternal[] memory swaps,\\n        IERC20[] memory tokens,\\n        FundManagement memory funds,\\n        SwapKind kind\\n    ) private nonReentrant returns (int256[] memory) {\\n        // Perform the swaps, updating the Pool balances and computing the net Vault token deltas\\n        int256[] memory tokenDeltas = _swapWithPools(swaps, tokens, funds, kind);\\n\\n        // Process token deltas, by either transferring tokens from the sender (for positive deltas) or to the recipient\\n        // (for negative deltas).\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n\\n            if (tokenDeltas[i] > 0) {\\n                uint128 toReceive = uint128(tokenDeltas[i]);\\n\\n                if (funds.fromInternalBalance) {\\n                    uint128 currentInternalBalance = _internalTokenBalance[msg.sender][token];\\n                    uint128 toWithdraw = uint128(Math.min(currentInternalBalance, toReceive));\\n\\n                    _internalTokenBalance[msg.sender][token] = currentInternalBalance - toWithdraw;\\n                    toReceive -= toWithdraw;\\n                }\\n\\n                token.safeTransferFrom(msg.sender, address(this), toReceive);\\n            } else {\\n                uint128 toSend = tokenDeltas[i].abs().toUint128();\\n\\n                if (funds.toInternalBalance) {\\n                    // Deposit tokens to the recipient's Internal Balance - the Vault's balance doesn't change\\n                    _internalTokenBalance[funds.recipient][token] = _internalTokenBalance[funds.recipient][token]\\n                        .add128(toSend);\\n                } else {\\n                    // Actually transfer the tokens to the recipient - note protocol withdraw fees are not charged by\\n                    // this\\n                    token.safeTransfer(funds.recipient, toSend);\\n                }\\n            }\\n        }\\n\\n        return tokenDeltas;\\n    }\\n\\n    // For `_batchSwap` to handle both given in and given out swaps, it internally tracks the 'given' amount (supplied\\n    // by the caller), and the 'quoted' one (returned by the Pool in response to the quote request).\\n\\n    /**\\n     * @dev Given the two swap tokens and the swap kind, returns which one is the 'given' token (the one for which the\\n     * amount is supplied by the caller).\\n     */\\n    function _tokenGiven(\\n        SwapKind kind,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut\\n    ) private pure returns (IERC20) {\\n        return kind == SwapKind.GIVEN_IN ? tokenIn : tokenOut;\\n    }\\n\\n    /**\\n     * @dev Given the two swap tokens and the swap kind, returns which one is the 'given' token (the one for which the\\n     * amount is returned by the Pool).\\n     */\\n    function _tokenQuoted(\\n        SwapKind kind,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut\\n    ) private pure returns (IERC20) {\\n        return kind == SwapKind.GIVEN_IN ? tokenOut : tokenIn;\\n    }\\n\\n    /**\\n     * @dev Returns an ordered pair (amountIn, amountOut) given the amounts given and quoted and the swap kind.\\n     */\\n    function _getAmounts(\\n        SwapKind kind,\\n        uint128 amountGiven,\\n        uint128 amountQuoted\\n    ) private pure returns (uint128 amountIn, uint128 amountOut) {\\n        if (kind == SwapKind.GIVEN_IN) {\\n            (amountIn, amountOut) = (amountGiven, amountQuoted);\\n        } else {\\n            (amountIn, amountOut) = (amountQuoted, amountGiven);\\n        }\\n    }\\n\\n    // This struct helps implement the multihop logic: if the amount given is not provided for a swap, then the token\\n    // given must match the previous token quoted, and the previous amount quoted becomes the new amount given.\\n    // For swaps of kind given in, amount in and token in are given, while amount out and token out quoted.\\n    // For swaps of kind given out, amount out and token out are given, while amount in and token in quoted.\\n    struct LastSwapData {\\n        IERC20 tokenQuoted;\\n        uint128 amountQuoted;\\n    }\\n\\n    /**\\n     * @dev Performs all `swaps`, requesting the Pools for quotes and updating their balances. Does not cause any\\n     * transfer of tokens - it instead returns the net Vault token deltas: positive if the Vault should receive tokens,\\n     * and negative if it should send them.\\n     */\\n    function _swapWithPools(\\n        SwapInternal[] memory swaps,\\n        IERC20[] memory tokens,\\n        FundManagement memory funds,\\n        SwapKind kind\\n    ) private returns (int256[] memory tokenDeltas) {\\n        tokenDeltas = new int256[](tokens.length);\\n\\n        // Passed to _swapWithPool, which stores data about the previous swap here to implement multihop logic across\\n        // swaps.\\n        LastSwapData memory previous;\\n\\n        // This variable could be declared inside the loop, but that causes the compiler to allocate memory on each loop\\n        // iteration, increasing gas costs.\\n        SwapInternal memory swap;\\n        for (uint256 i = 0; i < swaps.length; ++i) {\\n            swap = swaps[i];\\n            require(swap.tokenInIndex < tokens.length && swap.tokenOutIndex < tokens.length, \\\"ERR_INDEX_OUT_OF_BOUNDS\\\");\\n\\n            IERC20 tokenIn = tokens[swap.tokenInIndex];\\n            IERC20 tokenOut = tokens[swap.tokenOutIndex];\\n            require(tokenIn != tokenOut, \\\"Swap for same token\\\");\\n\\n            if (swap.amount == 0) {\\n                if (swaps.length > 1) {\\n                    // Sentinel value for multihop logic\\n                    // When the amount given is not provided, we use the amount quoted for the previous swap,\\n                    // assuming the current swap's token given is the previous' token quoted.\\n                    // This makes it possible to e.g. swap a given amount of token A for token B,\\n                    // and then use the resulting token B amount to swap for token C.\\n                    bool usingPreviousToken = previous.tokenQuoted == _tokenGiven(kind, tokenIn, tokenOut);\\n                    require(usingPreviousToken, \\\"Misconstructed multihop swap\\\");\\n                    swap.amount = previous.amountQuoted;\\n                } else {\\n                    revert(\\\"Unknown amount in on first swap\\\");\\n                }\\n            }\\n\\n            (uint128 amountIn, uint128 amountOut) = _swapWithPool(\\n                tokenIn,\\n                tokenOut,\\n                swap,\\n                msg.sender,\\n                funds.recipient,\\n                previous,\\n                kind\\n            );\\n\\n            // Accumulate Vault deltas across swaps\\n            tokenDeltas[swap.tokenInIndex] = SignedSafeMath.add(tokenDeltas[swap.tokenInIndex], amountIn);\\n            tokenDeltas[swap.tokenOutIndex] = SignedSafeMath.sub(tokenDeltas[swap.tokenOutIndex], amountOut);\\n\\n            emit Swap(swap.poolId, tokenIn, tokenOut, amountIn, amountOut);\\n        }\\n\\n        return tokenDeltas;\\n    }\\n\\n    /**\\n     * @dev Performs `swap`, updating the Pool balance. Returns a pair with the amount of tokens going into and out of\\n     * the Vault as a result of this swap.\\n     *\\n     * This function expects to be called with the `previous` swap struct, which will be updated internally to\\n     * implement multihop logic.\\n     */\\n    function _swapWithPool(\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        SwapInternal memory swap,\\n        address from,\\n        address to,\\n        LastSwapData memory previous,\\n        SwapKind kind\\n    ) private returns (uint128 amountIn, uint128 amountOut) {\\n        uint128 amountGiven = swap.amount.toUint128();\\n\\n        QuoteRequestInternal memory request = QuoteRequestInternal({\\n            tokenIn: tokenIn,\\n            tokenOut: tokenOut,\\n            amount: amountGiven,\\n            poolId: swap.poolId,\\n            from: from,\\n            to: to,\\n            userData: swap.userData\\n        });\\n\\n        // Get the quoted amount from the Pool and update its balances\\n        uint128 amountQuoted = _processQuoteRequest(request, kind);\\n\\n        // Store swap information for next pass\\n        previous.tokenQuoted = _tokenQuoted(kind, tokenIn, tokenOut);\\n        previous.amountQuoted = amountQuoted;\\n\\n        (amountIn, amountOut) = _getAmounts(kind, amountGiven, amountQuoted);\\n    }\\n\\n    /**\\n     * @dev Performs a quote request call to the Pool and updates its balances as a result of the swap being executed.\\n     * The interface used for the call will depend on the Pool's specialization setting.\\n     *\\n     * Returns the token amount quoted by the Pool.\\n     */\\n    function _processQuoteRequest(QuoteRequestInternal memory request, SwapKind kind)\\n        private\\n        returns (uint128 amountQuoted)\\n    {\\n        address pool = _getPoolAddress(request.poolId);\\n        PoolSpecialization specialization = _getPoolSpecialization(request.poolId);\\n\\n        if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\\n            amountQuoted = _processMinimalSwapInfoPoolQuoteRequest(request, IMinimalSwapInfoPoolQuote(pool), kind);\\n        } else if (specialization == PoolSpecialization.TWO_TOKEN) {\\n            amountQuoted = _processTwoTokenPoolQuoteRequest(request, IMinimalSwapInfoPoolQuote(pool), kind);\\n        } else {\\n            amountQuoted = _processGeneralPoolQuoteRequest(request, IGeneralPoolQuote(pool), kind);\\n        }\\n    }\\n\\n    function _processTwoTokenPoolQuoteRequest(\\n        QuoteRequestInternal memory request,\\n        IMinimalSwapInfoPoolQuote pool,\\n        SwapKind kind\\n    ) private returns (uint128 amountQuoted) {\\n        // Due to gas efficiency reasons, this function uses low-level knowledge of how Two Token Pool balances are\\n        // stored internally, instead of using getters and setters for all operations.\\n\\n        (\\n            bytes32 tokenABalance,\\n            bytes32 tokenBBalance,\\n            TwoTokenSharedBalances storage poolSharedBalances\\n        ) = _getTwoTokenPoolSharedBalances(request.poolId, request.tokenIn, request.tokenOut);\\n\\n        // We have the two Pool balances, but we don't know which one is the token in and which one is the token out.\\n        bytes32 tokenInBalance;\\n        bytes32 tokenOutBalance;\\n\\n        // In Two Token Pools, token A has a smaller address than token B\\n        if (request.tokenIn < request.tokenOut) {\\n            // in is A, out is B\\n            tokenInBalance = tokenABalance;\\n            tokenOutBalance = tokenBBalance;\\n        } else {\\n            // in is B, out is A\\n            tokenOutBalance = tokenABalance;\\n            tokenInBalance = tokenBBalance;\\n        }\\n\\n        uint128 tokenInTotalBalance = tokenInBalance.totalBalance();\\n        uint128 tokenOutTotalBalance = tokenOutBalance.totalBalance();\\n\\n        // Perform the quote request and compute the new balances for token in and token out after the swap\\n        if (kind == SwapKind.GIVEN_IN) {\\n            uint128 amountOut = pool\\n                .quoteOutGivenIn(_toQuoteGivenIn(request), tokenInTotalBalance, tokenOutTotalBalance)\\n                .toUint128();\\n\\n            tokenInBalance = tokenInBalance.increaseCash(request.amount.toUint128());\\n            tokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\\n\\n            amountQuoted = amountOut;\\n        } else {\\n            uint128 amountIn = pool\\n                .quoteInGivenOut(_toQuoteGivenOut(request), tokenInTotalBalance, tokenOutTotalBalance)\\n                .toUint128();\\n\\n            tokenInBalance = tokenInBalance.increaseCash(amountIn);\\n            tokenOutBalance = tokenOutBalance.decreaseCash(request.amount.toUint128());\\n\\n            amountQuoted = amountIn;\\n        }\\n\\n        // We check the token ordering again to create the new shared cash packed struct\\n        bytes32 newSharedCash;\\n        if (request.tokenIn < request.tokenOut) {\\n            // in is A, out is B\\n            newSharedCash = BalanceAllocation.toSharedCash(tokenInBalance, tokenOutBalance);\\n        } else {\\n            // in is B, out is A\\n            newSharedCash = BalanceAllocation.toSharedCash(tokenOutBalance, tokenInBalance);\\n        }\\n\\n        poolSharedBalances.sharedCash = newSharedCash;\\n    }\\n\\n    function _processMinimalSwapInfoPoolQuoteRequest(\\n        QuoteRequestInternal memory request,\\n        IMinimalSwapInfoPoolQuote pool,\\n        SwapKind kind\\n    ) private returns (uint128 amountQuoted) {\\n        bytes32 tokenInBalance = _getMinimalSwapInfoPoolBalance(request.poolId, request.tokenIn);\\n        bytes32 tokenOutBalance = _getMinimalSwapInfoPoolBalance(request.poolId, request.tokenOut);\\n\\n        uint128 tokenInTotalBalance = tokenInBalance.totalBalance();\\n        uint128 tokenOutTotalBalance = tokenOutBalance.totalBalance();\\n\\n        // Perform the quote request and compute the new balances for token in and token out after the swap\\n        if (kind == SwapKind.GIVEN_IN) {\\n            uint128 amountOut = pool\\n                .quoteOutGivenIn(_toQuoteGivenIn(request), tokenInTotalBalance, tokenOutTotalBalance)\\n                .toUint128();\\n\\n            tokenInBalance = tokenInBalance.increaseCash(request.amount.toUint128());\\n            tokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\\n\\n            amountQuoted = amountOut;\\n        } else {\\n            uint128 amountIn = pool\\n                .quoteInGivenOut(_toQuoteGivenOut(request), tokenInTotalBalance, tokenOutTotalBalance)\\n                .toUint128();\\n\\n            tokenInBalance = tokenInBalance.increaseCash(amountIn);\\n            tokenOutBalance = tokenOutBalance.decreaseCash(request.amount.toUint128());\\n\\n            amountQuoted = amountIn;\\n        }\\n\\n        _minimalSwapInfoPoolsBalances[request.poolId][request.tokenIn] = tokenInBalance;\\n        _minimalSwapInfoPoolsBalances[request.poolId][request.tokenOut] = tokenOutBalance;\\n    }\\n\\n    function _processGeneralPoolQuoteRequest(\\n        QuoteRequestInternal memory request,\\n        IGeneralPoolQuote pool,\\n        SwapKind kind\\n    ) private returns (uint128 amountQuoted) {\\n        bytes32 tokenInBalance;\\n        bytes32 tokenOutBalance;\\n\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[request.poolId];\\n        uint256 indexIn = poolBalances.indexOf(request.tokenIn, \\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n        uint256 indexOut = poolBalances.indexOf(request.tokenOut, \\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n\\n        uint256[] memory currentBalances = new uint256[](poolBalances.length());\\n\\n        uint256 tokenAmount = currentBalances.length;\\n        for (uint256 i = 0; i < tokenAmount; i++) {\\n            // Because the iteration is bounded by `tokenAmount` and no tokens are registered or unregistered here, we\\n            // can use `unchecked_valueAt` as we know `i` is a valid token index, saving storage reads.\\n            bytes32 balance = poolBalances.unchecked_valueAt(i);\\n\\n            currentBalances[i] = balance.totalBalance();\\n\\n            if (i == indexIn) {\\n                tokenInBalance = balance;\\n            } else if (i == indexOut) {\\n                tokenOutBalance = balance;\\n            }\\n        }\\n\\n        // Perform the quote request and compute the new balances for token in and token out after the swap\\n        if (kind == SwapKind.GIVEN_IN) {\\n            uint128 amountOut = pool\\n                .quoteOutGivenIn(_toQuoteGivenIn(request), currentBalances, indexIn, indexOut)\\n                .toUint128();\\n\\n            amountQuoted = amountOut;\\n            tokenInBalance = tokenInBalance.increaseCash(request.amount.toUint128());\\n            tokenOutBalance = tokenOutBalance.decreaseCash(amountOut);\\n        } else {\\n            uint128 amountIn = pool\\n                .quoteInGivenOut(_toQuoteGivenOut(request), currentBalances, indexIn, indexOut)\\n                .toUint128();\\n\\n            amountQuoted = amountIn;\\n            tokenInBalance = tokenInBalance.increaseCash(amountIn);\\n            tokenOutBalance = tokenOutBalance.decreaseCash(request.amount.toUint128());\\n        }\\n\\n        // Because no token registrations or unregistrations happened between now and when we retrieved the indexes for\\n        // token in and token out, we can use `unchecked_setAt`, saving storage reads.\\n        poolBalances.unchecked_setAt(indexIn, tokenInBalance);\\n        poolBalances.unchecked_setAt(indexOut, tokenOutBalance);\\n    }\\n\\n    function queryBatchSwapGivenIn(\\n        SwapIn[] memory swaps,\\n        IERC20[] calldata tokens,\\n        FundManagement calldata funds\\n    ) external override returns (int256[] memory) {\\n        // This function is not marked as `nonReentrant` because the underlying query mechanism relies on reentrancy\\n        return _callQueryBatchSwapHelper(_toInternalSwap(swaps), tokens, funds, SwapKind.GIVEN_IN);\\n    }\\n\\n    function queryBatchSwapGivenOut(\\n        SwapOut[] memory swaps,\\n        IERC20[] calldata tokens,\\n        FundManagement calldata funds\\n    ) external override returns (int256[] memory) {\\n        // This function is not marked as `nonReentrant` because the underlying query mechanism relies on reentrancy\\n        return _callQueryBatchSwapHelper(_toInternalSwap(swaps), tokens, funds, SwapKind.GIVEN_OUT);\\n    }\\n\\n    function _callQueryBatchSwapHelper(\\n        SwapInternal[] memory swaps,\\n        IERC20[] calldata tokens,\\n        FundManagement calldata funds,\\n        SwapKind kind\\n    ) private returns (int256[] memory tokenDeltas) {\\n        try this.queryBatchSwapHelper(swaps, tokens, funds, kind)  {\\n            // This call should never revert, but it is still useful to use the try-catch syntax as it provides\\n            // automatic decoding of the returndata.\\n            assert(false);\\n        } catch Error(string memory reason) {\\n            tokenDeltas = abi.decode(bytes(reason), (int256[]));\\n        }\\n    }\\n\\n    /**\\n     * @dev Despite this function being external, it can only be called by the Vault itself, and should not be\\n     * considered part of the Vault's external API.\\n     *\\n     * It executes the Pool interaction part of a batch swap, asking Pools for quotes and computing the Vault deltas,\\n     * but without performing any token transfers. It then reverts unconditionally, returning the Vault deltas array as\\n     * the revert data.\\n     *\\n     * This enables an accurate implementation of queryBatchSwapGivenIn and queryBatchSwapGivenOut, since the array\\n     * 'returned' by this function is the result of the exact same computation a swap would perform, including the Pool\\n     * calls.\\n     */\\n    function queryBatchSwapHelper(\\n        SwapInternal[] memory swaps,\\n        IERC20[] calldata tokens,\\n        FundManagement calldata funds,\\n        SwapKind kind\\n    ) external {\\n        require(msg.sender == address(this), \\\"Caller is not the Vault\\\");\\n        int256[] memory tokenDeltas = _swapWithPools(swaps, tokens, funds, kind);\\n        revert(string(abi.encode(tokenDeltas)));\\n    }\\n}\\n\",\"keccak256\":\"0x1f03133dd55937c29188010335fa1cdd596ba76299075b25d4d84c49430fa105\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./interfaces/IAuthorizer.sol\\\";\\n\\nimport \\\"./Authorization.sol\\\";\\nimport \\\"./FlashLoanProvider.sol\\\";\\nimport \\\"./Swaps.sol\\\";\\n\\n// solhint-disable no-empty-blocks\\n\\ncontract Vault is Authorization, FlashLoanProvider, Swaps {\\n    constructor(IAuthorizer authorizer) Authorization(authorizer) {}\\n}\\n\",\"keccak256\":\"0x117542def27b311ae8e3f49f67cd1752df227db309e8359b285899f7d91ba63c\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/balances/BalanceAllocation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\n\\nimport \\\"../../math/FixedPoint.sol\\\";\\n\\n// This library is used to create a data structure that represents a token's balance for a Pool. 'cash' is how many\\n// tokens the Pool has sitting inside of the Vault. 'managed' is how many tokens were withdrawn from the Vault by the\\n// Pool's Asset Manager. 'total' is the sum of these two, and represents the Pool's total token balance, including\\n// tokens that are *not* inside of the Vault.\\n//\\n// 'cash' is updated whenever tokens enter and exit the Vault, while 'managed' is only updated if the reason tokens are\\n// moving is due to an Asset Manager action. This is reflected in the different methods available: 'increaseCash'\\n// and 'decreaseCash' for swaps and add/remove liquidity events, and 'cashToManaged' and 'managedToCash' for\\n// events transferring funds to and from the asset manager.\\n//\\n// The Vault disallows the Pool's 'cash' ever becoming negative, in other words, it can never use any tokens that\\n// are not inside of the Vault.\\n//\\n// One of the goals of this library is to store the entire token balance in a single storage slot, which is we we use\\n// 128 bit unsigned integers for 'cash' and 'managed'. Since 'total' is also a 128 bit unsigned value, any combination\\n// of 'cash' and 'managed' that yields a 'total' that doesn't fit in that range is disallowed.\\n//\\n// We could use a Solidity struct to pack these two values together in a single storage slot, but unfortunately Solidity\\n// only allows for structs to live in either storage, calldata or memory. Because a memory struct still takes up a\\n// slot in the stack (to store its memory location), and because the entire balance fits in a single stack slot (two\\n// 128 bit values), using memory is strictly less gas performant. Therefore, we do manual packing and unpacking. The\\n// type we use to represent these values is bytes32, as it doesn't have any arithmetic operations and therefore reduces\\n// the chance of misuse.\\nlibrary BalanceAllocation {\\n    using FixedPoint for uint128;\\n\\n    // The 'cash' portion of the balance is stored in the least significant 128 bits of a 256 bit word, while the\\n    // 'managed' part uses the most significant 128 bits.\\n\\n    // Mask used to encode/decode pool balances into 'cash' and 'managed' balances\\n    uint128 private constant _MASK = 2**(128) - 1;\\n\\n    /**\\n     * @dev The amount of Pool tokens currently in the Vault.\\n     */\\n    function cashBalance(bytes32 balance) internal pure returns (uint128) {\\n        return uint128(uint256(balance)) & _MASK;\\n    }\\n\\n    /**\\n     * @dev The amount of Pool tokens that have been withdrawn by its Asset Manager.\\n     */\\n    function managedBalance(bytes32 balance) internal pure returns (uint128) {\\n        return uint128((uint256(balance) >> 128) & _MASK);\\n    }\\n\\n    /**\\n     * @dev The total amount of Pool tokens, including those that are not currently in the Vault ('managed').\\n     */\\n    function totalBalance(bytes32 balance) internal pure returns (uint128) {\\n        return cashBalance(balance).add128(managedBalance(balance));\\n    }\\n\\n    /**\\n     * @dev Tell whether the total amount is not zero\\n     */\\n    function isNotZero(bytes32 balance) internal pure returns (bool) {\\n        return !isZero(balance);\\n    }\\n\\n    /**\\n     * @dev Tell whether the total amount is zero\\n     */\\n    function isZero(bytes32 balance) internal pure returns (bool) {\\n        return balance == bytes32(0);\\n    }\\n\\n    /**\\n     * @dev Packs together cash and external amounts to create a balance value.\\n     *\\n     * Critically, this also checks the sum of cash and external doesn't overflow, that is, that `total()` can be\\n     * computed.\\n     */\\n    function toBalance(uint128 _cashBalance, uint128 _managedBalance) internal pure returns (bytes32) {\\n        uint128 total = _cashBalance + _managedBalance;\\n        require(total >= _cashBalance, \\\"BALANCE_TOTAL_OVERFLOW\\\");\\n\\n        return bytes32((uint256(_managedBalance) << 128) | _cashBalance);\\n    }\\n\\n    /**\\n     * @dev Increases a Pool's 'cash' (and therefore its 'total'). Called when Pool tokens are sent to the Vault (except\\n     * when an Asset Manager action decreases the managed balance).\\n     */\\n    function increaseCash(bytes32 balance, uint128 amount) internal pure returns (bytes32) {\\n        uint128 newCashBalance = cashBalance(balance).add128(amount);\\n        uint128 newManagedBalance = managedBalance(balance);\\n\\n        return toBalance(newCashBalance, newManagedBalance);\\n    }\\n\\n    /**\\n     * @dev Decreases a Pool's 'cash' (and therefore its 'total'). Called when Pool tokens are sent from the Vault\\n     * (except as an Asset Manager action that increases the managed balance).\\n     */\\n    function decreaseCash(bytes32 balance, uint128 amount) internal pure returns (bytes32) {\\n        uint128 newCashBalance = cashBalance(balance).sub128(amount);\\n        uint128 newManagedBalance = managedBalance(balance);\\n\\n        return toBalance(newCashBalance, newManagedBalance);\\n    }\\n\\n    /**\\n     * @dev Moves 'cash' into 'managed', leaving 'total' unchanged. Called when Pool tokens are sent from the Vault\\n     * when an Asset Manager action increases the managed balance.\\n     */\\n    function cashToManaged(bytes32 balance, uint128 amount) internal pure returns (bytes32) {\\n        uint128 newCashBalance = cashBalance(balance).sub128(amount);\\n        uint128 newManagedBalance = managedBalance(balance).add128(amount);\\n\\n        return toBalance(newCashBalance, newManagedBalance);\\n    }\\n\\n    /**\\n     * @dev Moves 'managed' into 'cash', leaving 'total' unchanged. Called when Pool tokens are sent to the Vault when\\n     * an Asset Manager action decreases the managed balance.\\n     */\\n    function managedToCash(bytes32 balance, uint128 amount) internal pure returns (bytes32) {\\n        uint128 newCashBalance = cashBalance(balance).add128(amount);\\n        uint128 newManagedBalance = managedBalance(balance).sub128(amount);\\n\\n        return toBalance(newCashBalance, newManagedBalance);\\n    }\\n\\n    /**\\n     * @dev Sets 'managed' balance to an arbitrary value, changing 'total'. Called when the Asset Manager reports\\n     * profits or losses. It's the Manager's responsibility to provide a meaningful value.\\n     */\\n    function setManagedBalance(bytes32 balance, uint128 newManagedBalance) internal pure returns (bytes32) {\\n        uint128 newCashBalance = cashBalance(balance);\\n\\n        return toBalance(newCashBalance, newManagedBalance);\\n    }\\n\\n    // Alternative mode for two token pools\\n\\n    // Instead of storing cash and external for each token in a single storage slot, two token pools store the cash for\\n    // both tokens in the same slot, and the external for both in another one. This reduces the gas cost for swaps,\\n    // because the only slot that needs to be updated is the one with the cash. However, it also means that managing\\n    // balances is more cumbersome, as both tokens need to be read/written at the same time.\\n    // The field with both cash balances packed is called sharedCash, and the one with external amounts is called\\n    // sharedManaged. These two are collectively called the 'shared' balance fields. In both of these, the portion\\n    // that corresponds to token A is stored in the most significant 128 bits of a 256 bit word, while token B's part\\n    // uses the least significant 128 bits.\\n\\n    /**\\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token A.\\n     */\\n    function fromSharedToBalanceA(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\\n        return toBalance(_decodeBalanceA(sharedCash), _decodeBalanceA(sharedManaged));\\n    }\\n\\n    /**\\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token B.\\n     */\\n    function fromSharedToBalanceB(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\\n        return toBalance(_decodeBalanceB(sharedCash), _decodeBalanceB(sharedManaged));\\n    }\\n\\n    /**\\n     * @dev Returns the sharedCash shared field, given the current balances for tokenA and tokenB.\\n     */\\n    function toSharedCash(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\\n        return bytes32((uint256(cashBalance(tokenABalance)) << 128) + cashBalance(tokenBBalance));\\n    }\\n\\n    /**\\n     * @dev Returns the sharedManaged shared field, given the current balances for tokenA and tokenB.\\n     */\\n    function toSharedManaged(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\\n        return bytes32((uint256(managedBalance(tokenABalance)) << 128) + managedBalance(tokenBBalance));\\n    }\\n\\n    /**\\n     * @dev Unpacks the balance corresponding to token A for a shared balance\\n     * Note that this function can be used to decode both cash and managed balances.\\n     */\\n    function _decodeBalanceA(bytes32 sharedBalance) private pure returns (uint128) {\\n        return uint128(uint256(sharedBalance >> 128) & _MASK);\\n    }\\n\\n    /**\\n     * @dev Unpacks the balance corresponding to token B for a shared balance\\n     * Note that this function can be used to decode both cash and managed balances.\\n     */\\n    function _decodeBalanceB(bytes32 sharedBalance) private pure returns (uint128) {\\n        return uint128(uint256(sharedBalance) & _MASK);\\n    }\\n}\\n\",\"keccak256\":\"0x1c0577964f60db51ee4b44c3690802203eeb885e02cedbe249c4840ab2fbd4e8\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/balances/GeneralPoolsBalance.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./BalanceAllocation.sol\\\";\\nimport \\\"../../math/FixedPoint.sol\\\";\\nimport \\\"../../vendor/EnumerableMap.sol\\\";\\n\\ncontract GeneralPoolsBalance {\\n    using SafeCast for uint256;\\n    using FixedPoint for int256;\\n    using BalanceAllocation for bytes32;\\n\\n    using EnumerableMap for EnumerableMap.IERC20ToBytes32Map;\\n\\n    // Data for Pools with General Pool Specialization setting\\n    //\\n    // These Pools use the IGeneralPoolQuote interface, which means the Vault must query the balance for *all* of their\\n    // tokens in every swap. If we kept a mapping of token to balance plus a set (array) of tokens, it'd be very gas\\n    // intensive to read all token addresses just to then do a lookup on the balance mapping.\\n    // Instead, we use our customized EnumerableMap, which lets us read the N balances in N+1 storage accesses (one for\\n    // the number of tokens in the Pool), as well as access the index of any token in a single read (required for the\\n    // IGeneralPoolQuote call) and update an entry's value given its index.\\n\\n    mapping(bytes32 => EnumerableMap.IERC20ToBytes32Map) internal _generalPoolsBalances;\\n\\n    /**\\n     * @dev Registers a list of tokens in a General Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - Each token must not be the zero address.\\n     * - Each token must not be registered in the Pool.\\n     */\\n    function _registerGeneralPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            require(token != IERC20(0), \\\"ERR_TOKEN_CANT_BE_ZERO\\\");\\n            bool added = poolBalances.set(token, 0);\\n            require(added, \\\"ERR_TOKEN_ALREADY_REGISTERED\\\");\\n            // No need to delete the balance entries, since they already are zero\\n        }\\n    }\\n\\n    /**\\n     * @dev Unregisters a list of tokens in a General Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - Each token must be registered in the Pool.\\n     * - Each token must have non balance in the Vault.\\n     */\\n    function _unregisterGeneralPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            bytes32 currentBalance = _getGeneralPoolBalance(poolBalances, token);\\n            require(currentBalance.isZero(), \\\"ERR_TOKEN_BALANCE_IS_NOT_ZERO\\\");\\n            poolBalances.remove(token);\\n        }\\n    }\\n\\n    /**\\n     * @dev Adds cash to a General Pool for a list of tokens. This function doesn't check that the lengths of\\n     * `tokens` and `amounts` match, it is responsibility of the caller to ensure that.\\n     *\\n     * Requirements:\\n     *\\n     * - Each token must be registered in the pool\\n     * - Amounts can be zero\\n     */\\n    function _increaseGeneralPoolCash(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts\\n    ) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            uint128 amount = amounts[i].toUint128();\\n            _updateGeneralPoolBalance(poolBalances, tokens[i], BalanceAllocation.increaseCash, amount);\\n        }\\n    }\\n\\n    function _alterGeneralPoolCash(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        int256[] memory amounts\\n    ) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            int256 amount = amounts[i];\\n\\n            _updateGeneralPoolBalance(\\n                poolBalances,\\n                tokens[i],\\n                amount > 0 ? BalanceAllocation.increaseCash : BalanceAllocation.decreaseCash,\\n                amount.abs().toUint128()\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes cash from a General Pool for a list of tokens. This function doesn't check that the lengths of\\n     * `tokens` and `amounts` match, it is responsibility of the caller to ensure that.\\n     *\\n     * Requirements:\\n     *\\n     * - Each token must be registered in the Pool.\\n     * - Each amount must be less or equal than the Pool's cash for that token.\\n     */\\n    function _decreaseGeneralPoolCash(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts\\n    ) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            uint128 amount = amounts[i].toUint128();\\n            _updateGeneralPoolBalance(poolBalances, tokens[i], BalanceAllocation.decreaseCash, amount);\\n        }\\n    }\\n\\n    function _generalPoolCashToManaged(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\\n    }\\n\\n    function _generalPoolManagedToCash(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.managedToCash, amount);\\n    }\\n\\n    function _setGeneralPoolManagedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateGeneralPoolBalance(poolId, token, BalanceAllocation.setManagedBalance, amount);\\n    }\\n\\n    function _updateGeneralPoolBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        function(bytes32, uint128) pure returns (bytes32) mutation,\\n        uint128 amount\\n    ) internal {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n        _updateGeneralPoolBalance(poolBalances, token, mutation, amount);\\n    }\\n\\n    function _updateGeneralPoolBalance(\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances,\\n        IERC20 token,\\n        function(bytes32, uint128) pure returns (bytes32) mutation,\\n        uint128 amount\\n    ) internal {\\n        bytes32 currentBalance = _getGeneralPoolBalance(poolBalances, token);\\n        poolBalances.set(token, mutation(currentBalance, amount));\\n    }\\n\\n    /**\\n     * @dev Returns an array with all the tokens and balances in a General Pool.\\n     * This order may change when tokens are added to or removed from the Pool.\\n     */\\n    function _getGeneralPoolTokens(bytes32 poolId)\\n        internal\\n        view\\n        returns (IERC20[] memory tokens, uint256[] memory balances)\\n    {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n        tokens = new IERC20[](poolBalances.length());\\n        balances = new uint256[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            // Because the iteration is bounded by `tokens.length` already fetched from the enumerable map,\\n            // we can use `unchecked_at` as we know `i` is a valid token index, saving storage reads.\\n            (IERC20 token, bytes32 balance) = poolBalances.unchecked_at(i);\\n            tokens[i] = token;\\n            balances[i] = balance.totalBalance();\\n        }\\n    }\\n\\n    function _getGeneralPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n        return _getGeneralPoolBalance(poolBalances, token);\\n    }\\n\\n    function _getGeneralPoolBalance(EnumerableMap.IERC20ToBytes32Map storage poolBalances, IERC20 token)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return poolBalances.get(token, \\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n    }\\n\\n    function _isGeneralPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\\n        EnumerableMap.IERC20ToBytes32Map storage poolBalances = _generalPoolsBalances[poolId];\\n        return poolBalances.contains(token);\\n    }\\n}\\n\",\"keccak256\":\"0x36b3719ed1a821a6bb7137bb40071ba0da5cba3717570fd130007e4142ab7047\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/balances/MinimalSwapInfoPoolsBalance.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\n\\nimport \\\"./BalanceAllocation.sol\\\";\\nimport \\\"../../math/FixedPoint.sol\\\";\\n\\ncontract MinimalSwapInfoPoolsBalance {\\n    using SafeCast for uint256;\\n    using FixedPoint for int256;\\n    using BalanceAllocation for bytes32;\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Data for Pools with Minimal Swap Info Specialization setting\\n    //\\n    // These Pools use the IMinimalSwapInfoPoolQuote interface, and so the Vault must read the balance of the two tokens\\n    // in the swap. The best solution is to use a mapping from token to balance, which lets us read or write any token's\\n    // balance in a single storage access.\\n    // We also keep a set with all tokens in the Pool, and update this set when cash is added or removed from the pool.\\n    // Tokens in the set always have a non-zero balance, so we don't need\\n    // to check the set for token existence during a swap: the non-zero balance check achieves this for less gas.\\n\\n    mapping(bytes32 => EnumerableSet.AddressSet) internal _minimalSwapInfoPoolsTokens;\\n    mapping(bytes32 => mapping(IERC20 => bytes32)) internal _minimalSwapInfoPoolsBalances;\\n\\n    /**\\n     * @dev Registers a list of tokens in a Minimal Swap Info Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - Each token must not be the zero address.\\n     * - Each token must not be registered in the Pool.\\n     */\\n    function _registerMinimalSwapInfoPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            require(token != IERC20(0), \\\"ERR_TOKEN_CANT_BE_ZERO\\\");\\n            bool added = poolTokens.add(address(token));\\n            require(added, \\\"ERR_TOKEN_ALREADY_REGISTERED\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Unregisters a list of tokens in a Minimal Swap Info Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - Each token must be registered in the Pool.\\n     * - Each token must have non balance in the Vault.\\n     */\\n    function _unregisterMinimalSwapInfoPoolTokens(bytes32 poolId, IERC20[] memory tokens) internal {\\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            require(_minimalSwapInfoPoolsBalances[poolId][token].isZero(), \\\"ERR_TOKEN_BALANCE_IS_NOT_ZERO\\\");\\n            bool removed = poolTokens.remove(address(token));\\n            require(removed, \\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n            // No need to delete the balance entries, since they already are zero\\n        }\\n    }\\n\\n    /**\\n     * @dev Adds cash to a Minimal Swap Info Pool for a list of tokens. This function doesn't check that the lengths of\\n     * `tokens` and `amounts` match, it is responsibility of the caller to ensure that.\\n     *\\n     * Requirements:\\n     *\\n     * - Each token must be registered in the pool\\n     * - Amounts can be zero\\n     */\\n    function _increaseMinimalSwapInfoPoolCash(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts\\n    ) internal {\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            uint128 amount = amounts[i].toUint128();\\n            _updateMinimalSwapInfoPoolBalance(poolId, tokens[i], BalanceAllocation.increaseCash, amount);\\n        }\\n    }\\n\\n    function _alterMinimalSwapInfoPoolCash(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        int256[] memory amounts\\n    ) internal {\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            int256 amount = amounts[i];\\n            _updateMinimalSwapInfoPoolBalance(\\n                poolId,\\n                tokens[i],\\n                amount > 0 ? BalanceAllocation.increaseCash : BalanceAllocation.decreaseCash,\\n                amount.abs().toUint128()\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes cash from a  Minimal Swap Info Pool for a list of tokens. This function doesn't check that the\\n     * lengths of `tokens` and `amounts` match, it is responsibility of the caller to ensure that.\\n     *\\n     * Requirements:\\n     *\\n     * - Each token must be registered in the Pool.\\n     * - Each amount must be less or equal than the Pool's cash for that token.\\n     */\\n    function _decreaseMinimalSwapInfoPoolCash(\\n        bytes32 poolId,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts\\n    ) internal {\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            uint128 amount = amounts[i].toUint128();\\n            _updateMinimalSwapInfoPoolBalance(poolId, tokens[i], BalanceAllocation.decreaseCash, amount);\\n        }\\n    }\\n\\n    function _minimalSwapInfoPoolCashToManaged(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\\n    }\\n\\n    function _minimalSwapInfoPoolManagedToCash(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.managedToCash, amount);\\n    }\\n\\n    function _setMinimalSwapInfoPoolManagedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateMinimalSwapInfoPoolBalance(poolId, token, BalanceAllocation.setManagedBalance, amount);\\n    }\\n\\n    function _updateMinimalSwapInfoPoolBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        function(bytes32, uint128) pure returns (bytes32) mutation,\\n        uint128 amount\\n    ) internal {\\n        bytes32 currentBalance = _getMinimalSwapInfoPoolBalance(poolId, token);\\n        _minimalSwapInfoPoolsBalances[poolId][token] = mutation(currentBalance, amount);\\n    }\\n\\n    /**\\n     * @dev Returns an array with all the tokens and balances in a Minimal Swap Info Pool.\\n     * This order may change when tokens are added to or removed from the Pool.\\n     */\\n    function _getMinimalSwapInfoPoolTokens(bytes32 poolId)\\n        internal\\n        view\\n        returns (IERC20[] memory tokens, uint256[] memory balances)\\n    {\\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\\n        tokens = new IERC20[](poolTokens.length());\\n        balances = new uint256[](tokens.length);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = IERC20(poolTokens.at(i));\\n            tokens[i] = token;\\n            balances[i] = _minimalSwapInfoPoolsBalances[poolId][token].totalBalance();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the balance for a token in a Minimal Swap Info Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - `token` must be in the Pool.\\n     */\\n    function _getMinimalSwapInfoPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\\n        bytes32 balance = _minimalSwapInfoPoolsBalances[poolId][token];\\n        bool existsToken = balance.isNotZero() || _minimalSwapInfoPoolsTokens[poolId].contains(address(token));\\n        require(existsToken, \\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n        return balance;\\n    }\\n\\n    function _isMinimalSwapInfoPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\\n        EnumerableSet.AddressSet storage poolTokens = _minimalSwapInfoPoolsTokens[poolId];\\n        return poolTokens.contains(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x1556b64d361643c50c04e45d94ca73a75a07c7ae8df58deacfa69925979c1d15\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/balances/TwoTokenPoolsBalance.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../math/FixedPoint.sol\\\";\\n\\nimport \\\"./BalanceAllocation.sol\\\";\\n\\ncontract TwoTokenPoolsBalance {\\n    using SafeCast for uint256;\\n    using FixedPoint for int256;\\n    using BalanceAllocation for bytes32;\\n\\n    // Data for Pools with Two Tokens\\n    //\\n    // These are similar to the Minimal Swap Info Pool case (because the Pool only has two tokens, and therefore there\\n    // are only two balances to read), but there's a key difference in how data is stored. Keeping a set makes little\\n    // sense, as it will only ever hold two tokens, so we can just store those two directly.\\n    // The gas savings associated with using these Pools come from how token balances are stored: cash for token A and\\n    // token B is packed together, as are external amounts. Because only cash changes in a swap, there's no need to\\n    // write to this second storage slot.\\n    // This however makes Vault code that interacts with these Pools cumbersome: both balances must be accessed at the\\n    // same time by using both token addresses, and some logic is needed to differentiate token A from token B. In this\\n    // case, token A is always the token with the lowest numerical address value. The token X and token Y names are used\\n    // in functions when it is unknown which one is A and which one is B.\\n\\n    struct TwoTokenTokens {\\n        IERC20 tokenA;\\n        IERC20 tokenB;\\n    }\\n\\n    struct TwoTokenSharedBalances {\\n        bytes32 sharedCash;\\n        bytes32 sharedManaged;\\n    }\\n\\n    mapping(bytes32 => TwoTokenTokens) internal _poolTwoTokenTokens;\\n\\n    // We could just keep a mapping from Pool ID to TwoTokenSharedBalances, but there's an issue: we wouldn't know to\\n    // which tokens those balances correspond. This would mean having to also check the tokens struct in a swap, to make\\n    // sure the tokens being swapped are the ones in the Pool.\\n    // What we do instead to save those storage reads is keep a nested mapping from token pair hash to the balances\\n    // struct. The Pool only has two tokens, so only a single entry of this mapping is set (the one that corresponds to\\n    // that pair's hash). This means queries for token pairs where any of the tokens is not in the Pool will generate a\\n    // hash for a mapping entry that was not set, containing zero balances. Non-zero balances are only possible if both\\n    // tokens in the pair are the Pool's tokens, which means we don't have to check the TwoTokensTokens struct and save\\n    // storage reads.\\n    mapping(bytes32 => mapping(bytes32 => TwoTokenSharedBalances)) internal _poolTwoTokenSharedBalances;\\n\\n    /**\\n     * @dev Registers the tokens of a Two Token Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenX` and `tokenY` cannot be the same.\\n     * - Both tokens must not be the zero address.\\n     * - Both tokens must not be registered in the Pool.\\n     */\\n    function _registerTwoTokenPoolTokens(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        IERC20 tokenY\\n    ) internal {\\n        require(tokenX != IERC20(0) && tokenY != IERC20(0), \\\"ERR_TOKEN_CANT_BE_ZERO\\\");\\n\\n        // Not technically true since we didn't register yet, but this is consistent with the error messages of other\\n        // specialization settings.\\n        require(tokenX != tokenY, \\\"ERR_TOKEN_ALREADY_REGISTERED\\\");\\n\\n        TwoTokenTokens memory poolTokens = _poolTwoTokenTokens[poolId];\\n        require(poolTokens.tokenA == IERC20(0) && poolTokens.tokenB == IERC20(0), \\\"ERR_TOKENS_ALREADY_SET\\\");\\n\\n        (IERC20 tokenA, IERC20 tokenB) = _sortTwoTokens(tokenX, tokenY);\\n        _poolTwoTokenTokens[poolId] = TwoTokenTokens({ tokenA: tokenA, tokenB: tokenB });\\n    }\\n\\n    /**\\n     * @dev Unregisters the tokens of a Two Token Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenX` and `tokenY` must be the Pool's tokens.\\n     * - Both tokens must have non balance in the Vault.\\n     */\\n    function _unregisterTwoTokenPoolTokens(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        IERC20 tokenY\\n    ) internal {\\n        (bytes32 tokenABalance, bytes32 tokenBBalance, ) = _getTwoTokenPoolSharedBalances(poolId, tokenX, tokenY);\\n        require(tokenABalance.isZero() && tokenBBalance.isZero(), \\\"ERR_TOKEN_BALANCE_IS_NOT_ZERO\\\");\\n\\n        delete _poolTwoTokenTokens[poolId];\\n        // No need to delete the balance entries, since they already are zero\\n    }\\n\\n    /**\\n     * @dev Adds cash to a Two Token Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenX` and `tokenY` must be the Pool's tokens.\\n     */\\n    function _increaseTwoTokenPoolCash(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        uint128 amountX,\\n        IERC20 tokenY,\\n        uint128 amountY\\n    ) internal {\\n        _updateTwoTokenPoolCashBalance(poolId, tokenX, amountX, tokenY, amountY, BalanceAllocation.increaseCash);\\n    }\\n\\n    function _alterTwoTokenPoolCash(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        int256 amountX,\\n        IERC20 tokenY,\\n        int256 amountY\\n    ) internal {\\n        _updateTwoTokenPoolCashBalance(\\n            poolId,\\n            tokenX,\\n            amountX.abs().toUint128(),\\n            amountX > 0 ? BalanceAllocation.increaseCash : BalanceAllocation.decreaseCash,\\n            tokenY,\\n            amountY.abs().toUint128(),\\n            amountY > 0 ? BalanceAllocation.increaseCash : BalanceAllocation.decreaseCash\\n        );\\n    }\\n\\n    /**\\n     * @dev Removes cash from a Two Token Pool.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenX` and `tokenY` must be the Pool's tokens.\\n     * - `amountX` and `amountY` must be less or equal than the Pool's cash for the respective token.\\n     */\\n    function _decreaseTwoTokenPoolCash(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        uint128 amountX,\\n        IERC20 tokenY,\\n        uint128 amountY\\n    ) internal {\\n        _updateTwoTokenPoolCashBalance(poolId, tokenX, amountX, tokenY, amountY, BalanceAllocation.decreaseCash);\\n    }\\n\\n    function _twoTokenPoolCashToManaged(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.cashToManaged, amount);\\n    }\\n\\n    function _twoTokenPoolManagedToCash(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.managedToCash, amount);\\n    }\\n\\n    function _setTwoTokenPoolManagedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint128 amount\\n    ) internal {\\n        _updateTwoTokenPoolSharedBalance(poolId, token, BalanceAllocation.setManagedBalance, amount);\\n    }\\n\\n    function _updateTwoTokenPoolCashBalance(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        uint128 amountX,\\n        IERC20 tokenY,\\n        uint128 amountY,\\n        function(bytes32, uint128) pure returns (bytes32) mutation\\n    ) private {\\n        (\\n            bytes32 tokenABalance,\\n            bytes32 tokenBBalance,\\n            TwoTokenSharedBalances storage poolSharedBalances\\n        ) = _getTwoTokenPoolSharedBalances(poolId, tokenX, tokenY);\\n\\n        if (tokenX < tokenY) {\\n            // X is A, Y is B\\n            tokenABalance = mutation(tokenABalance, amountX);\\n            tokenBBalance = mutation(tokenBBalance, amountY);\\n        } else {\\n            // X is B, Y is A\\n            tokenABalance = mutation(tokenABalance, amountY);\\n            tokenBBalance = mutation(tokenBBalance, amountX);\\n        }\\n\\n        poolSharedBalances.sharedCash = BalanceAllocation.toSharedCash(tokenABalance, tokenBBalance);\\n        // We don't need to write to the sharedManaged entry\\n    }\\n\\n    function _updateTwoTokenPoolCashBalance(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        uint128 amountX,\\n        function(bytes32, uint128) pure returns (bytes32) mutationX,\\n        IERC20 tokenY,\\n        uint128 amountY,\\n        function(bytes32, uint128) pure returns (bytes32) mutationY\\n    ) private {\\n        (\\n            bytes32 tokenABalance,\\n            bytes32 tokenBBalance,\\n            TwoTokenSharedBalances storage poolSharedBalances\\n        ) = _getTwoTokenPoolSharedBalances(poolId, tokenX, tokenY);\\n\\n        if (tokenX < tokenY) {\\n            // X is A, Y is B\\n            tokenABalance = mutationX(tokenABalance, amountX);\\n            tokenBBalance = mutationY(tokenBBalance, amountY);\\n        } else {\\n            // X is B, Y is A\\n            tokenABalance = mutationY(tokenABalance, amountY);\\n            tokenBBalance = mutationX(tokenBBalance, amountX);\\n        }\\n\\n        poolSharedBalances.sharedCash = BalanceAllocation.toSharedCash(tokenABalance, tokenBBalance);\\n        // We don't need to write to the sharedManaged entry\\n    }\\n\\n    function _updateTwoTokenPoolSharedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        function(bytes32, uint128) pure returns (bytes32) mutation,\\n        uint128 amount\\n    ) private {\\n        TwoTokenTokens memory poolTokens = _poolTwoTokenTokens[poolId];\\n        bytes32 pairHash = _getTwoTokenPairHash(poolTokens.tokenA, poolTokens.tokenB);\\n        TwoTokenSharedBalances storage poolSharedBalances = _poolTwoTokenSharedBalances[poolId][pairHash];\\n\\n        bytes32 sharedCash = poolSharedBalances.sharedCash;\\n        bytes32 sharedManaged = poolSharedBalances.sharedManaged;\\n\\n        bytes32 tokenABalance = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\\n        bytes32 tokenBBalance = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\\n\\n        if (token == poolTokens.tokenA) {\\n            tokenABalance = mutation(tokenABalance, amount);\\n        } else if (token == poolTokens.tokenB) {\\n            tokenBBalance = mutation(tokenBBalance, amount);\\n        } else {\\n            revert(\\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n        }\\n\\n        poolSharedBalances.sharedCash = BalanceAllocation.toSharedCash(tokenABalance, tokenBBalance);\\n        poolSharedBalances.sharedManaged = BalanceAllocation.toSharedManaged(tokenABalance, tokenBBalance);\\n    }\\n\\n    /**\\n     * @dev Returns the balance for a token pair in a Two Token Pool, reverting if either of the tokens is\\n     * not registered by the Pool.\\n     *\\n     * The returned balances are those of token A and token B, where token A is the lowest of token X and token Y, and\\n     * token B the other.\\n     *\\n     * This function also returns a storage pointer to the TwoTokenSharedBalances entry associated with the token pair,\\n     * which can be used to update this entry without having to recompute the pair hash and storage slot.\\n     */\\n    function _getTwoTokenPoolSharedBalances(\\n        bytes32 poolId,\\n        IERC20 tokenX,\\n        IERC20 tokenY\\n    )\\n        internal\\n        view\\n        returns (\\n            bytes32 tokenABalance,\\n            bytes32 tokenBBalance,\\n            TwoTokenSharedBalances storage poolSharedBalances\\n        )\\n    {\\n        (IERC20 tokenA, IERC20 tokenB) = _sortTwoTokens(tokenX, tokenY);\\n        bytes32 pairHash = _getTwoTokenPairHash(tokenA, tokenB);\\n        poolSharedBalances = _poolTwoTokenSharedBalances[poolId][pairHash];\\n\\n        bytes32 sharedCash = poolSharedBalances.sharedCash;\\n        bytes32 sharedManaged = poolSharedBalances.sharedManaged;\\n\\n        // Only registered tokens can have non-zero balances, so we can use this as a shortcut to avoid the\\n        // expensive _hasPoolTwoTokens check.\\n        bool exists = sharedCash.isNotZero() || sharedManaged.isNotZero() || _hasPoolTwoTokens(poolId, tokenA, tokenB);\\n        require(exists, \\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n\\n        tokenABalance = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\\n        tokenBBalance = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\\n    }\\n\\n    function _hasPoolTwoTokens(\\n        bytes32 poolId,\\n        IERC20 tokenA,\\n        IERC20 tokenB\\n    ) internal view returns (bool) {\\n        TwoTokenTokens memory poolTokens = _poolTwoTokenTokens[poolId];\\n        return poolTokens.tokenA == tokenA && tokenB == poolTokens.tokenB;\\n    }\\n\\n    function _isTwoTokenPoolTokenRegistered(bytes32 poolId, IERC20 token) internal view returns (bool) {\\n        TwoTokenTokens memory poolTokens = _poolTwoTokenTokens[poolId];\\n        return (token == poolTokens.tokenA || token == poolTokens.tokenB) && token != IERC20(0);\\n    }\\n\\n    /**\\n     * @dev Returns an array with all the tokens and balances in a Two Token Pool.\\n     * This array will have either two or zero entries (if the Pool doesn't have any tokens).\\n     */\\n    function _getTwoTokenPoolTokens(bytes32 poolId)\\n        internal\\n        view\\n        returns (IERC20[] memory tokens, uint256[] memory balances)\\n    {\\n        // Both tokens will either be zero or non-zero, but we keep the full check for clarity\\n        TwoTokenTokens memory poolTokens = _poolTwoTokenTokens[poolId];\\n        if (poolTokens.tokenA == IERC20(0) || poolTokens.tokenB == IERC20(0)) {\\n            return (new IERC20[](0), new uint256[](0));\\n        }\\n\\n        tokens = new IERC20[](2);\\n        tokens[0] = poolTokens.tokenA;\\n        tokens[1] = poolTokens.tokenB;\\n\\n        balances = new uint256[](2);\\n        bytes32 pairHash = _getTwoTokenPairHash(poolTokens.tokenA, poolTokens.tokenB);\\n        TwoTokenSharedBalances storage poolSharedBalance = _poolTwoTokenSharedBalances[poolId][pairHash];\\n        bytes32 sharedCash = poolSharedBalance.sharedCash;\\n        bytes32 sharedManaged = poolSharedBalance.sharedManaged;\\n        balances[0] = BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged).totalBalance();\\n        balances[1] = BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged).totalBalance();\\n    }\\n\\n    /**\\n     * @dev Returns the balance for a token in a Two Token Pool.\\n     *\\n     * This function is convenient but not particularly gas efficient, and should be avoided during gas-sensitive\\n     * operations, such as swaps. For those, _getTwoTokenPoolSharedBalances provides a more flexible interface.\\n     *\\n     * Requirements:\\n     *\\n     * - `token` must be in the Pool.\\n     */\\n    function _getTwoTokenPoolBalance(bytes32 poolId, IERC20 token) internal view returns (bytes32) {\\n        // We can't just read the balance of token, because we need to know the full pair in order to compute the pair\\n        // hash and access the balance mapping. We therefore also read the TwoTokenTokens struct.\\n        TwoTokenTokens memory poolTokens = _poolTwoTokenTokens[poolId];\\n        bytes32 pairHash = _getTwoTokenPairHash(poolTokens.tokenA, poolTokens.tokenB);\\n        TwoTokenSharedBalances storage poolSharedBalance = _poolTwoTokenSharedBalances[poolId][pairHash];\\n\\n        bytes32 sharedCash = poolSharedBalance.sharedCash;\\n        bytes32 sharedManaged = poolSharedBalance.sharedManaged;\\n\\n        if (token == poolTokens.tokenA) {\\n            return BalanceAllocation.fromSharedToBalanceA(sharedCash, sharedManaged);\\n        } else if (token == poolTokens.tokenB) {\\n            return BalanceAllocation.fromSharedToBalanceB(sharedCash, sharedManaged);\\n        } else {\\n            revert(\\\"ERR_TOKEN_NOT_REGISTERED\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a hash associated with a given token pair.\\n     */\\n    function _getTwoTokenPairHash(IERC20 tokenA, IERC20 tokenB) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(tokenA, tokenB));\\n    }\\n\\n    /**\\n     * @dev Sorts two tokens ascendingly, returning them as a (tokenA, tokenB) tuple.\\n     */\\n    function _sortTwoTokens(IERC20 tokenX, IERC20 tokenY) private pure returns (IERC20, IERC20) {\\n        return tokenX < tokenY ? (tokenX, tokenY) : (tokenY, tokenX);\\n    }\\n}\\n\",\"keccak256\":\"0x540f32398d668fadd41120e04b3d5c40737d3f9f835ec1f33a159e0c3a845a24\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IAuthorizer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IAuthorizer {\\n    function canChangeAuthorizer(address account) external view returns (bool);\\n\\n    function canSetProtocolWithdrawFee(address account) external view returns (bool);\\n\\n    function canSetProtocolSwapFee(address account) external view returns (bool);\\n\\n    function canSetProtocolFlashLoanFee(address account) external view returns (bool);\\n\\n    function canWithdrawProtocolFees(address account, IERC20 token) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xee4b1644c550403cce7830d03ebe2fe6f4ce3a2aa450dcf8ab0e0bcbf5de22b6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IFlashLoanReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFlashLoanReceiver {\\n    function receiveFlashLoan(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        uint256[] calldata feeAmounts,\\n        bytes calldata receiverData\\n    ) external;\\n}\\n\",\"keccak256\":\"0xbe46da7c5fff72bad25d0c79e603273a8ad965399aa561ce928556034d7257c6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IGeneralPoolQuote.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPoolQuoteStructs.sol\\\";\\n\\ninterface IGeneralPoolQuote {\\n    function quoteOutGivenIn(\\n        IPoolQuoteStructs.QuoteRequestGivenIn calldata request,\\n        uint256[] calldata balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) external returns (uint256 amountOut);\\n\\n    function quoteInGivenOut(\\n        IPoolQuoteStructs.QuoteRequestGivenOut calldata request,\\n        uint256[] calldata balances,\\n        uint256 indexIn,\\n        uint256 indexOut\\n    ) external returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0xc9cb4268a31087861727506279c508126ac47a1f0e7cc11f792f09015daade51\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IMinimalSwapInfoPoolQuote.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPoolQuoteStructs.sol\\\";\\n\\ninterface IMinimalSwapInfoPoolQuote {\\n    function quoteOutGivenIn(\\n        IPoolQuoteStructs.QuoteRequestGivenIn calldata request,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) external returns (uint256 amountOut);\\n\\n    function quoteInGivenOut(\\n        IPoolQuoteStructs.QuoteRequestGivenOut calldata request,\\n        uint256 currentBalanceTokenIn,\\n        uint256 currentBalanceTokenOut\\n    ) external returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0x54d3d932ec32f1e7d8c4de76d2d71783bba2529aa0d888a9caae4a06d12352aa\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IVault.sol\\\";\\n\\ninterface IPool {\\n    function getVault() external view returns (IVault);\\n\\n    function getPoolId() external view returns (bytes32);\\n\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.joinPool`. The Pool must return how many tokens the user\\n     * should provide for each registered token, as well as how many protocol fees the Pool owes to the Vault. After\\n     * returning, the Vault will take tokens from the `sender` and add it to the Pool's balance, as well as collect\\n     * reported protocol fees.\\n     *\\n     * Due protocol fees are reported and charged on join events so that new users join the Pool free of debt.\\n     *\\n     * `sender` is the account performing the join (from whom tokens will be withdrawn), and `recipient` an account\\n     * designated to receive any benefits (typically pool shares). `currentBalances` contains the total token balances\\n     * for each token the Pool registered in the Vault, in the same order as found there.\\n     *\\n     * Contracts implementing this should check that the caller is indeed the Vault before performing any state-changing\\n     * operations, such as minting pool shares.\\n     */\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] calldata currentBalances,\\n        uint256[] calldata maxAmountsIn,\\n        uint256 protocolSwapFee,\\n        bytes calldata userData\\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\\n\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.exitPool`. The Pool must return how many tokens the Vault\\n     * should deduct from the Pool, as well as how many protocol fees the Pool owes to the Vault. After returning, the\\n     * Vault will take tokens from the Pool's balance and add grant them to `recipient`, as well as collect reported\\n     * protocol fees.\\n     *\\n     * Due protocol fees are reported and charged on exit events so that users exit the Pool having paid all debt.\\n     *\\n     * `sender` is the account performing the exit (typically the holder of pool shares), and `recipient` the account to\\n     * which the Vault will grant tokens. `currentBalances` contains the total token balances for each token the Pool\\n     * registered in the Vault, in the same order as found there.\\n     *\\n     * Contracts implementing this should check that the caller is indeed the Vault before performing any state-changing\\n     * operations, such as burning pool shares.\\n     */\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] calldata currentBalances,\\n        uint256[] calldata minAmountsOut,\\n        uint256 protocolSwapFee,\\n        bytes calldata userData\\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\\n}\\n\",\"keccak256\":\"0x7503d6bc9155cfc1cdf4d4937ccddaed724df655750bad85c30182e8446f11bd\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IPoolQuoteStructs.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.1;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IPoolQuoteStructs {\\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPoolQuote and\\n    // IMinimalSwapInfoPoolQuote.\\n\\n    // This data structure represents a request for a token swap, where the amount received by the Pool is known.\\n    //\\n    // `tokenIn` and `tokenOut` are the tokens the Pool will receive and send, respectively. `amountIn` is the number of\\n    // `tokenIn` tokens that the Pool will receive.\\n    //\\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\\n    // some Pools.\\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\\n    // one Pool.\\n    // `from` is the origin address where funds the Pool receives are coming from, and `to` is the destination address\\n    // where the funds the Pool sends are going to.\\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\\n    struct QuoteRequestGivenIn {\\n        IERC20 tokenIn;\\n        IERC20 tokenOut;\\n        uint256 amountIn;\\n        // Misc data\\n        bytes32 poolId;\\n        address from;\\n        address to;\\n        bytes userData;\\n    }\\n\\n    // This data structure represents a request for a token swap, where the amount sent by the Pool is known.\\n    //\\n    // `tokenIn` and `tokenOut` are the tokens the Pool will receive and send, respectively. `amountOut` is the number\\n    // of `tokenOut` tokens that the Pool will send.\\n    //\\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\\n    // some Pools.\\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\\n    // one Pool.\\n    // `from` is the origin address where funds the Pool receives are coming from, and `to` is the destination address\\n    // where the funds the Pool sends are going to.\\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\\n    struct QuoteRequestGivenOut {\\n        IERC20 tokenIn;\\n        IERC20 tokenOut;\\n        uint256 amountOut;\\n        // Misc data\\n        bytes32 poolId;\\n        address from;\\n        address to;\\n        bytes userData;\\n    }\\n}\\n\",\"keccak256\":\"0x56e55492632e2edd9c8351befb1abee7bdc16c93becc8dcd7aa56e108049a0f5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/ISwapValidator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma experimental ABIEncoderV2;\\n\\npragma solidity ^0.7.1;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\n\\ninterface ISwapValidator {\\n    function validate(\\n        IERC20[] calldata tokens,\\n        int256[] calldata vaultDeltas,\\n        //address caller, //TODO: is it useful to validate?\\n        //address from, //TODO: is it useful to validate?\\n        //address to, //TODO: is it useful to validate?\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcba00166b3a122dad6a5c3aa7d8ecbdea1bc79aa4ba63995ff14a190ba07e7d5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IFlashLoanReceiver.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\nimport \\\"./ISwapValidator.sol\\\";\\n\\npragma solidity ^0.7.1;\\n\\n// Full external interface for the Vault core contract - no external or public methods exist in the contract that don't\\n// override one of these declarations.\\n//\\n// All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g. while\\n// execution control is transferred to a token contract during a transfer) will result in a revert. View functions can\\n// be called, but they might return inconsistent results if called in a reentrant manner.\\ninterface IVault {\\n    // Internal Balance\\n\\n    /**\\n     * @dev Returns `user`'s Internal Balance for a specific token.\\n     */\\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Deposits tokens from the caller into `user`'s Internal Balance. The caller must have allowed the Vault\\n     * to use their tokens via `IERC20.approve()`.\\n     */\\n    function depositToInternalBalance(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        address user\\n    ) external;\\n\\n    /**\\n     * @dev Withdraws tokens from the caller's Internal Balance, transferring them to `recipient`.\\n     * This charges protocol withdrawal fees.\\n     */\\n    function withdrawFromInternalBalance(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        address recipient\\n    ) external;\\n\\n    /**\\n     * @dev Transfers tokens from the caller's Internal Balance, transferring them to `recipient`'s Internal Balance.\\n     * This does not charge protocol withdrawal fees.\\n     */\\n    function transferInternalBalance(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        address recipient\\n    ) external;\\n\\n    // Pools\\n\\n    // There are three specialization levels for Pools, which allow for lower swap gas costs at the cost of reduced\\n    // functionality:\\n    //\\n    //  - general: no specialization, IGeneralPoolQuote is used to ask for quotes, passing the balance of all tokens in\\n    // the Pool. Swaps cost more gas the more tokens the Pool has (because of the extra storage reads).\\n    //\\n    //  - minimal swap info: IMinimalSwapInfoPoolQuote is used instead, which saves gas by only passes the balance of\\n    // the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted constant\\n    // product one popularized by Balancer v1. Swap gas cost is independent of the number of tokens in the Pool.\\n    //\\n    //  - two tokens: this level achieves the lowest possible swap gas costs by restricting Pools to only having two\\n    // tokens, which allows for a specialized balance packing format. Like minimal swap info Pools, these are called via\\n    // IMinimalSwapInfoPoolQuote.\\n\\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\\n\\n    /**\\n     * @dev Registers a the caller as a Pool, with selected specialization level.\\n     *\\n     * Returns the Pool's ID. Also emits a PoolCreated event.\\n     */\\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n    /**\\n     * @dev Emitted when a Pool is created by calling `registerPool`. Contains the Pool ID of the registered pool.\\n     */\\n    event PoolCreated(bytes32 poolId);\\n\\n    // Pool Queries\\n\\n    /**\\n     * @dev Returns the number of Pools.\\n     */\\n    function getNumberOfPools() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a partial list of Pool IDs, starting at index `start`, up to index `end`.\\n     */\\n    function getPoolIds(uint256 start, uint256 end) external view returns (bytes32[] memory);\\n\\n    // These functions revert if querying a Pool that doesn't exist\\n\\n    /**\\n     * @dev Returns a Pool's address and specialization level.\\n     */\\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n    /**\\n     * @dev Returns the Pool's tokens and total balances. This means it will refer also to the assets held by the Pool's\\n     * Asset Manager and not currently held by the Vault.\\n     */\\n    function getPoolTokens(bytes32 poolId) external view returns (IERC20[] memory tokens, uint256[] memory balances);\\n\\n    /**\\n     * @dev Returns the Pool's token cash and managed balances.\\n     */\\n    function getPoolTokenBalanceInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        returns (uint256 cash, uint256 managed);\\n\\n    // Pool Management\\n\\n    /**\\n     * @dev Called by the Pool to register `tokens`. A Pool can only add and remove liquidity for tokens it has\\n     * registered, and all swaps with a Pool must involve registered tokens.\\n     *\\n     * Each token in `tokens` must not be already registered before this call. For Pools with the Two Token\\n     * specialization, `tokens` must have a length of two, that is, both tokens must be registered at the same time.\\n     *\\n     * Also define the asset manager for each token at registration time\\n     * (can be the zero address, if a token is unmanaged)\\n     */\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] calldata tokens,\\n        address[] calldata assetManagers\\n    ) external;\\n\\n    event TokensRegistered(bytes32 poolId, IERC20[] tokens);\\n\\n    /**\\n     * @dev Called by the Pool to unregisted `tokens`. This prevents adding and removing liquidity in the future, as\\n     * well as swaps. Unregistered tokens can be re-registered in the future.\\n     *\\n     *\\n     * Each token in `tokens` must be registered before this call, and have zero balance. For Pools with the Two Token\\n     * specialization, `tokens` must have a length of two, that is, both tokens must be unregistered at the same time.\\n     */\\n    function unregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\\n\\n    event TokensUnregistered(bytes32 poolId, IERC20[] tokens);\\n\\n    /**\\n     * @dev Called by users to join a Pool, transferring tokens into its balance. The `IPool.onJoinPool` hook will be\\n     * called on the Pool by the Vault, which will typically grant something to the user in return - often tokenized\\n     * Pool shares.\\n     *\\n     * `maxAmountsIn` is the maximum amount of tokens the user is willing to provide to the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * Pools are free to implement any arbitrary logic in the `IPool.onJoinPool` hook, and may require additional\\n     * information (such as the expected number of Pool shares to obtain). This can be encoded in the `userData`\\n     * argument, which is ignored by the Vault and passed directly to the Pool, as is `recipient`.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and Internal Balance (if any).\\n     */\\n    function joinPool(\\n        bytes32 poolId,\\n        address recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory maxAmountsIn,\\n        bool fromInternalBalance,\\n        bytes memory userData\\n    ) external;\\n\\n    event PoolJoined(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        uint256[] amountsIn,\\n        uint256[] protocolFees\\n    );\\n\\n    /**\\n     * @dev Called by users to exit a Pool, transferring tokens from its balance. The `IPool.onExitPool` hook will be\\n     * called on the Pool by the Vault, which will typically take something to the user in return - often tokenized\\n     * Pool shares.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * Pools are free to implement any arbitrary logic in the `IPool.onExitPool` hook, and may require additional\\n     * information (such as the number of Pool shares to provide). This can be encoded in the `userData` argument, which\\n     * is ignored by the Vault and passed directly to the Pool.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed, and charged protocol withdraw fees accordingly.\\n     */\\n    function exitPool(\\n        bytes32 poolId,\\n        address recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory minAmountsOut,\\n        bool tointernalBalance,\\n        bytes memory userData\\n    ) external;\\n\\n    event PoolExited(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        uint256[] amountsOut,\\n        uint256[] protocolFees\\n    );\\n\\n    // Swap interface\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each swap, the amount of tokens sent to the Pool\\n     * is known. For swaps where the amount of tokens received from the Pool is known, see `batchSwapGivenOut`.\\n     *\\n     * Returns an array with the net Vault token balance deltas. Positive amounts represent tokens sent to the Vault,\\n     * and negative amounts tokens sent by the Vault. Each delta corresponds to the token at the same index in the\\n     * `tokens` array.\\n     *\\n     * A `validator` can be optionally supplied, and if so it will be called with `tokens`, the Vault deltas, and\\n     * user-supplied `validatorData`. This is useful to check a swap has happened according to user expectations (and\\n     * wasn't, for example, affected by other transactions), and potentially revert if not.\\n     *\\n     * Each swap is executed independently in the order specified by the `swaps` array. However, tokens are only\\n     * transferred in and out of the Vault (or withdrawn from and deposited into the User's Internal Balance) after\\n     * all swaps have been completed and the net token balance change computed. This means it is possible to e.g.\\n     * under certain conditions perform arbitrage by swapping with multiple Pools in a way that results in net token\\n     * movement out of the Vault (profit), with no tokens being sent in (but updating the Pool's internal balances).\\n     *\\n     * The `swaps` array contains the information about each individual swaps. All swaps consist of a Pool receiving\\n     * some amount of one of its tokens (`tokenIn`), and sending some amount of another one of its tokens (`tokenOut`).\\n     * The `tokenOut` amount is determined by the Pool's pricing algorithm by calling the `quoteOutGivenIn` function\\n     * (from IGeneralPoolQuote or IMinimalSwapInfoPoolQuote).\\n     *\\n     * Multihop swaps, where one token is exchanged for another one by passing through one or more intermediate tokens,\\n     * can be executed by passing an `amountIn` value of zero for a swap. This will cause the amount out of the previous\\n     * swap to be used as the amount in of the current one. In such a scenario, `tokenIn` must equal the previous swap's\\n     * `tokenOut`.\\n     *\\n     * The `tokens` array contains the addresses of all tokens involved in the swaps.\\n     *\\n     * Funds will be sent and  received according to the data in the `funds` struct.\\n     */\\n    function batchSwapGivenIn(\\n        ISwapValidator validator,\\n        bytes calldata validatorData,\\n        SwapIn[] calldata swaps,\\n        IERC20[] memory tokens,\\n        FundManagement calldata funds\\n    ) external returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for a swap executed via `batchSwapGivenIn`. The tokens in and out are indexed in the `tokens` array\\n     * passed to that function.\\n     *\\n     * `amountIn` tokens are sent to the `poolId` Pool for the token in, and `userData` is forwarded to the Pool in the\\n     * `quoteOutGivenIn` function. If `amountIn` is zero, the multihop mechanism is used to determine the actual amount.\\n     */\\n    struct SwapIn {\\n        bytes32 poolId;\\n        uint256 tokenInIndex;\\n        uint256 tokenOutIndex;\\n        uint256 amountIn;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each swap, the amount of tokens received from the\\n     * Pool is known. For swaps where the amount of tokens sent to the Pool is known, see `batchSwapGivenIn`.\\n     *\\n     * Returns an array with the net Vault token balance deltas. Positive amounts represent tokens sent to the Vault,\\n     * and negative amounts tokens sent by the Vault. Each delta corresponds to the token at the same index in the\\n     * `tokens` array.\\n     *\\n     * A `validator` can be optionally supplied, and if so it will be called with `tokens`, the Vault deltas, and\\n     * user-supplied `validatorData`. This is useful to check a swap has happened according to user expectations (and\\n     * wasn't, for example, affected by other transactions), and potentially revert if not.\\n     *\\n     * Each swap is executed independently in the order specified by the `swaps` array. However, tokens are only\\n     * transferred in and out of the Vault (or withdrawn from and deposited into the User's Internal Balance) after\\n     * all swaps have been completed and the net token balance change computed. This means it is possible to e.g.\\n     * under certain conditions perform arbitrage by swapping with multiple Pools in a way that results in net token\\n     * movement out of the Vault (profit), with no tokens being sent in (but updating the Pool's internal balances).\\n     *\\n     * The `swaps` array contains the information about each individual swaps. All swaps consist of a Pool receiving\\n     * some amount of one of its tokens (`tokenIn`), and sending some amount of another one of its tokens (`tokenOut`).\\n     * The `tokenIn` amount is determined by the Pool's pricing algorithm by calling the `quoteInGivenOut` function\\n     * (from IGeneralPoolQuote or IMinimalSwapInfoPoolQuote).\\n     *\\n     * Multihop swaps, where one token is exchanged for another one by passing through one or more intermediate tokens,\\n     * can be executed by passing an `amountOut` value of zero for a swap. This will cause the amount in of the previous\\n     * swap to be used as the amount out of the current one. In such a scenario, `tokenOut` must equal the previous\\n     * swap's `tokenIn`.\\n     *\\n     * The `tokens` array contains the addresses of all tokens involved in the swaps.\\n     *\\n     * Funds will be sent and  received according to the data in the `funds` struct.\\n     */\\n    function batchSwapGivenOut(\\n        ISwapValidator validator,\\n        bytes calldata validatorData,\\n        SwapOut[] calldata swaps,\\n        IERC20[] memory tokens,\\n        FundManagement calldata funds\\n    ) external returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for a swap executed via `batchSwapGivenOut`. The tokens in and out are indexed in the `tokens` array\\n     * passed to that function.\\n     *\\n     * `amountOut` tokens are received from the `poolId` Pool for the token out, and `userData` is forwarded to the Pool\\n     *  in the `quoteInGivenOut` function. If `amountOut` is zero, the multihop mechanism is used to determine the\\n     * actual amount.\\n     */\\n    struct SwapOut {\\n        bytes32 poolId;\\n        uint256 tokenInIndex;\\n        uint256 tokenOutIndex;\\n        uint256 amountOut;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev All tokens in a swap are sent to the Vault from the caller's account, and sent to `recipient`.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The caller\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *     * If `tointernalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     */\\n    struct FundManagement {\\n        address recipient;\\n        bool fromInternalBalance;\\n        bool toInternalBalance;\\n    }\\n\\n    // Swap query methods\\n\\n    /**\\n     * @dev Simulates a call to batchSwapGivenIn, returning an array of Vault token deltas. Each element in the array\\n     * corresponds to the token at the same index, and indicates the number of tokens the Vault would take from the\\n     * caller (if positive) or send to the recipient (if negative). The arguments it receives are the same that\\n     * an equivalent batchSwapGivenIn would receive.\\n     *\\n     * Unlike batchSwapGivenIn, this function performs no checks on its caller nor the recipient field in the\\n     * FundsManagement struct. This makes it suitable to be called by off-chain applications via eth_call without\\n     * needing to hold tokens, approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n    function queryBatchSwapGivenIn(\\n        SwapIn[] memory swaps,\\n        IERC20[] calldata tokens,\\n        FundManagement calldata funds\\n    ) external returns (int256[] memory);\\n\\n    /**\\n     * @dev Simulates a call to batchSwapGivenOut, returning an array of Vault token deltas. Each element in the array\\n     * corresponds to the token at the same index, and indicates the number of tokens the Vault would take from the\\n     * caller (if positive) or send to the recipient (if negative). The arguments it receives are the same that\\n     * an equivalent batchSwapGivenOut would receive.\\n     *\\n     * Unlike batchSwapGivenOut, this function performs no checks on its caller nor the recipient field in the\\n     * FundsManagement struct. This makes it suitable to be called by off-chain applications via eth_call without\\n     * needing to hold tokens, approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n    function queryBatchSwapGivenOut(\\n        SwapOut[] memory swaps,\\n        IERC20[] calldata tokens,\\n        FundManagement calldata funds\\n    ) external returns (int256[] memory);\\n\\n    // Flash Loan interface\\n\\n    /**\\n     * @dev Performs a flash loan where 'amount' tokens of 'token' are sent to 'receiver', which must implement the\\n     * IFlashLoanReceiver interface. An arbitrary user-provided 'receiverData' is forwarded to this contract.\\n     *\\n     * Before returning from the IFlashLoanReceiver.receiveFlashLoan call, the receiver must transfer back the loaned\\n     * tokens, plus a proportional protocol fee.\\n     */\\n    function flashLoan(\\n        IFlashLoanReceiver receiver,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        bytes calldata receiverData\\n    ) external;\\n\\n    // Asset management interface\\n\\n    /**\\n     * @dev Returns a Pool's Asset Manager for `token`. Asset Managers can manage a Pool's assets by taking\\n     * them out of the Vault via `withdrawFromPoolBalance`, `depositToPoolBalance` and `updateManagedBalance`.\\n     */\\n    function getPoolAssetManager(bytes32 poolId, IERC20 token) external view returns (address);\\n\\n    /**\\n     * @dev Called by a Pool's Asset Manager for `token` to withdraw `amount` tokens from the Vault. This decreases\\n     * the Pool's cash but increases its managed balance, leaving the total balance unchanged.\\n     */\\n    function withdrawFromPoolBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @dev Called by a Pool's Asset Manager for `token` to deposit `amount` tokens into the Vault. This increases\\n     * the Pool's cash but decreases its managed balance, leaving the total balance unchanged. The Asset Manager\\n     * must have approved the Vault to use `token`.\\n     */\\n    function depositToPoolBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @dev Called by a Pool's Asset Manager for `token` to update the external amount. This causes no change on\\n     * the Pool's cash, but because the managed balance changes, so does the total balance. The external amount can be\\n     * both increased and decreased by this call.\\n     */\\n    function updateManagedBalance(\\n        bytes32 poolId,\\n        IERC20 token,\\n        uint256 amount\\n    ) external;\\n\\n    // Authorizer\\n\\n    /**\\n     * @dev Returns the Vault's Authorizer.\\n     */\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    /**\\n     * @dev Sets a new Authorizer for the Vault.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be approved by the authorizer (`IAuthorizer.canChangeAuthorizer`).\\n     */\\n    function changeAuthorizer(IAuthorizer newAuthorizer) external;\\n\\n    // Protocol Fees\\n\\n    /**\\n     * @dev Returns the Protocol Withdraw Fee. Withdraw fees are applied on `withdraw` and `exitPool` (unless\\n     * depositing into User's Internal Balance). Swaps and `withdrawFromPoolBalance` are not charged withdraw fees.\\n     *\\n     * This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee.\\n     */\\n    function getProtocolWithdrawFee() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the Protocol Swap Fee. These are paid by Pools via `paySwapProtocolFees`.\\n     *\\n     * This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee.\\n     */\\n    function getProtocolSwapFee() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the Protocol Flash Loan Fee. These are collected on all Flash Loans.\\n     *\\n     * This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee.\\n     */\\n    function getProtocolFlashLoanFee() external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a new Protocol Withdraw Fee.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolWithdrawFee`).\\n     */\\n    function setProtocolWithdrawFee(uint256 newFee) external;\\n\\n    /**\\n     * @dev Sets a new Protocol Swap Fee.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolSwapFee`).\\n     */\\n    function setProtocolSwapFee(uint256 newFee) external;\\n\\n    /**\\n     * @dev Sets a new Protocol Flash Loan Fee.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolFlashLoanFee`).\\n     */\\n    function setProtocolFlashLoanFee(uint256 newFee) external;\\n\\n    /**\\n     * @dev Returns the amount of protocol fees collected by the Vault for `token`.\\n     */\\n    function getCollectedFeesByToken(IERC20 token) external view returns (uint256);\\n\\n    /**\\n     * @dev Withdraws collected protocol fees.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be approved by the authorizer (`IAuthorizer.canWithdrawProtocolFees`) for each token.\\n     */\\n    function withdrawProtocolFees(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external;\\n}\\n\",\"keccak256\":\"0x744a7008484128dbb7c7631229b3981dc6536708b40e1131c48b273e52909c6f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vendor/EnumerableMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.1;\\n\\n// Based on the EnumerableSet library from OpenZeppelin contracts, altered to include\\n// the following:\\n//  * a map from IERC20 to bytes32\\n//  * entries are stored in mappings instead of arrays, reducing implicit storage reads for out-of-bounds checks\\n//  * _unchecked_at and _unchecked_valueAt, which allow for more gas efficient data reads in some scenarios\\n//  * _indexOf and _unchecked_setAt, which allow for more gas efficient data writes in some scenarios\\n\\n// We're using non-standard casing for the unchecked functions to differentiate them, so we need to turn off that rule\\n// solhint-disable func-name-mixedcase\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Number of entries in the map\\n        uint256 _length;\\n        // Storage of map keys and values\\n        mapping(uint256 => MapEntry) _entries;\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(\\n        Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to !contains(map, key)\\n        if (keyIndex == 0) {\\n            uint256 previousLength = map._length;\\n            map._entries[previousLength] = MapEntry({ _key: key, _value: value });\\n            map._length = previousLength + 1;\\n\\n            // The entry is stored at previousLength, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = previousLength + 1;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key`, which can be used alongside the {at} family of functions, including critically\\n     * {unchecked_setAt}. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _indexOf(Map storage map, bytes32 key) private view returns (uint256) {\\n        return _indexOf(map, key, \\\"EnumerableMap: nonexistent key\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {_indexOf}, with a custom error message when `key` is not in the map.\\n     */\\n    function _indexOf(\\n        Map storage map,\\n        bytes32 key,\\n        string memory notFoundErrorMessage\\n    ) private view returns (uint256) {\\n        uint256 index = map._indexes[key];\\n        require(index > 0, notFoundErrorMessage);\\n        return index - 1;\\n    }\\n\\n    /**\\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via {indexOf}, and it\\n     * should be noted that key indices may change when calling {add} or {remove}. O(1).\\n     *\\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\\n     * whithin bounds.\\n     */\\n    function _unchecked_setAt(\\n        Map storage map,\\n        uint256 index,\\n        bytes32 value\\n    ) private {\\n        map._entries[index]._value = value;\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        // Equivalent to contains(map, key)\\n        if (keyIndex != 0) {\\n            // To delete a key-value pair from the _entries pseudo-array in O(1), we swap the entry to delete with the\\n            // one at the highest index, and then remove this last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the pseudo-array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            delete map._entries[lastIndex];\\n            map._length = lastIndex;\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._length;\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is\\n     * equal or larger than {length}). O(1).\\n     *\\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function _unchecked_at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Same as {unchecked_valueAt}, except it only returns the value and not the key (performing one less storage\\n     * read). O(1).\\n     */\\n    function _unchecked_valueAt(Map storage map, uint256 index) private view returns (bytes32) {\\n        return map._entries[index]._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        return _get(map, key, \\\"EnumerableMap: nonexistent key\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     */\\n    function _get(\\n        Map storage map,\\n        bytes32 key,\\n        string memory notFoundErrorMessage\\n    ) private view returns (bytes32) {\\n        uint256 index = _indexOf(map, key, notFoundErrorMessage);\\n        return _unchecked_valueAt(map, index);\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key`, which can be used alongside the {at} family of functions, including critically\\n     * {unchecked_setAt}. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function indexOf(UintToAddressMap storage map, uint256 key) internal view returns (uint256) {\\n        return _indexOf(map._inner, bytes32(uint256(address(key))));\\n    }\\n\\n    /**\\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via {indexOf}, and it\\n     * should be noted that key indices may change when calling {add} or {remove}. O(1).\\n     *\\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\\n     * whithin bounds.\\n     */\\n    function unchecked_setAt(\\n        UintToAddressMap storage map,\\n        uint256 index,\\n        address value\\n    ) internal {\\n        _unchecked_setAt(map._inner, index, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is\\n     * equal or larger than {length}). O(1).\\n     *\\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _unchecked_at(map._inner, index);\\n        return (uint256(key), address(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Same as {unchecked_valueAt}, except it only returns the value and not the key (performing one less storage\\n     * read). O(1).\\n     */\\n    function unchecked_valueAt(UintToAddressMap storage map, uint256 index) internal view returns (address) {\\n        return address(uint256(_unchecked_valueAt(map._inner, index)));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\\n    }\\n\\n    // IERC20ToBytes32Map\\n\\n    struct IERC20ToBytes32Map {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(uint256(address(key))), value);\\n    }\\n\\n    /**\\n     * @dev Returns the index for `key`, which can be used alongside the {at} family of functions, including critically\\n     * {unchecked_setAt}. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function indexOf(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (uint256) {\\n        return _indexOf(map._inner, bytes32(uint256(address(key))));\\n    }\\n\\n    /**\\n     * @dev Same as {indexOf}, with a custom error message when `key` is not in the map.\\n     */\\n    function indexOf(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        string memory notFoundErrorMessage\\n    ) internal view returns (uint256) {\\n        return _indexOf(map._inner, bytes32(uint256(address(key))), notFoundErrorMessage);\\n    }\\n\\n    /**\\n     * @dev Updates the value for an entry, given its key's index. The key index can be retrieved via {indexOf}, and it\\n     * should be noted that key indices may change when calling {add} or {remove}. O(1).\\n     *\\n     * This function performs one less storage read than {set}, but it should only be used when `index` is known to be\\n     * whithin bounds.\\n     */\\n    function unchecked_setAt(\\n        IERC20ToBytes32Map storage map,\\n        uint256 index,\\n        bytes32 value\\n    ) internal {\\n        _unchecked_setAt(map._inner, index, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(IERC20ToBytes32Map storage map, IERC20 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(uint256(address(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(uint256(address(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(IERC20ToBytes32Map storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (IERC20(uint256(key)), value);\\n    }\\n\\n    /**\\n     * @dev Same as {at}, except this doesn't revert if `index` it outside of the map (i.e. if it is\\n     * equal or larger than {length}). O(1).\\n     *\\n     * This function performs one less storage read than {at}, but should only be used when `index` is known to be\\n     * within bounds.\\n     */\\n    function unchecked_at(IERC20ToBytes32Map storage map, uint256 index) internal view returns (IERC20, bytes32) {\\n        (bytes32 key, bytes32 value) = _unchecked_at(map._inner, index);\\n        return (IERC20(uint256(key)), value);\\n    }\\n\\n    /**\\n     * @dev Same as {unchecked_valueAt}, except it only returns the value and not the key (performing one less storage\\n     * read). O(1).\\n     */\\n    function unchecked_valueAt(IERC20ToBytes32Map storage map, uint256 index) internal view returns (bytes32) {\\n        return _unchecked_valueAt(map._inner, index);\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(IERC20ToBytes32Map storage map, IERC20 key) internal view returns (bytes32) {\\n        return _get(map._inner, bytes32(uint256(address(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(\\n        IERC20ToBytes32Map storage map,\\n        IERC20 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        return _get(map._inner, bytes32(uint256(address(key))), errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xee2b9c0ee4ddb59d260f562bc9a6b93c1d9a29c1c6a7a8bf96b9cbb9a225c2ae\",\"license\":\"MIT\"},\"contracts/vendor/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.1;\\n\\n// Based on the ReentrancyGuard library from OpenZeppelin contracts, altered to reduce bytecode size.\\n// Modifier code is inlined by the compiler, which causes its code to appear multiple times in the codebase. By using\\n// private functions, we achieve the same end result with sligthly higher runtime gas costs but reduced bytecode size.\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function _enterNonReentrant() private {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _exitNonReentrant() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xfadc88751f66e67dcc11a3a45f04812546f5373b307e866e2be4b43239e7c9a3\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60e0604052620000536064620000366002670de0b6b3a76400006001600160801b03166200012960201b620028d31790919060201c565b6001600160801b0316620001f560201b6200298e1790919060201c565b608090811b6001600160801b03191690526200008b606462000036670de0b6b3a7640000603262000129602090811b620028d317901c565b60801b6001600160801b03191660a052620000c2606462000036670de0b6b3a7640000603262000129602090811b620028d317901c565b6001600160801b031660c052348015620000db57600080fd5b5060405162007e5838038062007e58833981016040819052620000fe91620002ed565b6001600081905580546001600160a01b0319166001600160a01b039290921691909117905562000397565b60008282026001600160801b0384161580620001725750826001600160801b0316846001600160801b0316826001600160801b0316816200016657fe5b046001600160801b0316145b6200019a5760405162461bcd60e51b8152600401620001919062000347565b60405180910390fd5b6706f05b59d3b2000081016001600160801b038083169082161015620001d45760405162461bcd60e51b8152600401620001919062000347565b6000670de0b6b3a76400006001600160801b0383165b049695505050505050565b60006001600160801b038216620002205760405162461bcd60e51b8152600401620001919062000371565b670de0b6b3a764000083026001600160801b0384161580620002685750670de0b6b3a76400006001600160801b03858116908316816200025c57fe5b046001600160801b0316145b620002875760405162461bcd60e51b815260040162000191906200031d565b600060026001600160801b0385160482019050816001600160801b0316816001600160801b03161015620002cf5760405162461bcd60e51b815260040162000191906200031d565b6000846001600160801b0316826001600160801b031681620001ea57fe5b600060208284031215620002ff578081fd5b81516001600160a01b038116811462000316578182fd5b9392505050565b60208082526010908201526f11549497d1125597d25395115493905360821b604082015260600190565b60208082526010908201526f4552525f4d554c5f4f564552464c4f5760801b604082015260600190565b6020808252600c908201526b4552525f4449565f5a45524f60a01b604082015260600190565b60805160801c60a05160801c60c051617a8e620003ca600039806125ec5250806110ee525080610f6b5250617a8e6000f3fe608060405234801561001057600080fd5b50600436106102265760003560e01c80637576b5f11161012a578063c3946977116100bd578063e6a329091161008c578063f6c0092711610071578063f6c009271461048e578063f90e6570146104af578063f94d4668146104c257610226565b8063e6a3290914610468578063f0f5fd551461047b57610226565b8063c39469771461041c578063c4cd53db1461042f578063d1b33a4814610442578063ddbada601461045557610226565b80638adc5f5d116100f95780638adc5f5d146103e3578063a297857814610404578063aaabadc51461040c578063bb61f6351461041457610226565b80637576b5f1146103a257806375e9cfb7146103b5578063761c52e6146103c85780637a7d3f74146103d057610226565b806323eeca01116101bd5780634b4039f61161018c5780635c38449e116101715780635c38449e1461036957806366a9c7d21461037c57806370c5ae2c1461038f57610226565b80634b4039f6146103435780635233cd6b1461035657610226565b806323eeca01146102ea5780632b8a61631461030a578063379162c41461031d57806338b025051461033057610226565b80630f5a6efa116101f95780630f5a6efa146102915780631adcfe0d146102b15780631faddee5146102c457806321a6eb13146102d757610226565b806307dfca131461022b57806309b2760f146102495780630c0626421461025c5780630e9e98cf1461027c575b600080fd5b6102336104e3565b6040516102409190616a25565b60405180910390f35b6102336102573660046164d8565b6104f3565b61026f61026a3660046162ef565b6105ad565b6040516102409190616796565b61028f61028a366004615e03565b6105ee565b005b6102a461029f366004615e1f565b610708565b604051610240919061691a565b61028f6102bf36600461622e565b6107f3565b61028f6102d236600461617a565b610a10565b6102a46102e53660046163e2565b610cf3565b6102fd6102f8366004616564565b610de9565b6040516102409190616828565b61028f610318366004616162565b610ea2565b6102a461032b366004615ff3565b610fec565b6102a461033e366004615ff3565b61100d565b61028f610351366004616162565b611025565b61028f61036436600461631e565b611170565b61028f610377366004616355565b611283565b61028f61038a366004616278565b6116e7565b61028f61039d36600461631e565b611962565b61028f6103b036600461617a565b611a16565b61028f6103c336600461606c565b611cc7565b610233611d6e565b61028f6103de366004615eee565b611d7f565b6103f66103f13660046162ef565b611f78565b6040516102409291906178eb565b610233612015565b61026f612038565b610233612047565b61028f61042a366004615eee565b61204d565b6102a461043d366004616497565b612247565b61028f61045036600461631e565b6122a0565b61028f610463366004615eee565b6123a2565b61028f610476366004616162565b612523565b61028f610489366004615e6d565b612647565b6104a161049c366004616162565b61281c565b6040516102409291906167e8565b6102336104bd366004615e03565b612846565b6104d56104d0366004616162565b612865565b6040516102409291906168a7565b6003546001600160801b03165b90565b6000600260005414156105215760405162461bcd60e51b8152600401610518906177e3565b60405180910390fd5b6002600090815561053c3384610537600b612a7a565b612a85565b9050600061054b600b83612ad7565b90508061056a5760405162461bcd60e51b81526004016105189061727c565b7f76c4350174727086805a3b026998a38a23dec4eaa173f2eb5449eb961e69c043826040516105999190616a25565b60405180910390a150600160005592915050565b6000826105b981612ae3565b6105c38484612b0d565b50506000918252600d602090815260408084206001600160a01b039384168552909152909120541690565b600260005414156106115760405162461bcd60e51b8152600401610518906177e3565b60026000556001546040517fa962e8690000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063a962e8699061065f903390600401616796565b60206040518083038186803b15801561067757600080fd5b505afa15801561068b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106af9190616146565b6106cb5760405162461bcd60e51b815260040161051890617247565b600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0392909216919091178155600055565b606080825167ffffffffffffffff8111801561072357600080fd5b5060405190808252806020026020018201604052801561074d578160200160208202803683370190505b50905060005b83518110156107e9576001600160a01b0385166000908152600560205260408120855190919086908490811061078557fe5b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002060009054906101000a90046001600160801b03166001600160801b03168282815181106107d657fe5b6020908102919091010152600101610753565b5090505b92915050565b600260005414156108165760405162461bcd60e51b8152600401610518906177e3565b60026000558261082581612b37565b600061083085612b75565b9050600281600281111561084057fe5b14156108b857600283146108665760405162461bcd60e51b815260040161051890617145565b6108b3858585600081811061087757fe5b905060200201602081019061088c9190615e03565b8686600181811061089957fe5b90506020020160208101906108ae9190615e03565b612b8b565b610946565b60018160028111156108c657fe5b1415610909576108b385858580806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612c1b92505050565b61094685858580806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612cd392505050565b60005b838110156109c8576000868152600d602052604081209086868481811061096c57fe5b90506020020160208101906109819190615e03565b6001600160a01b03168152602081019190915260400160002080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055600101610949565b507f12f8276099dfd84906c19325f6d9886ec2317c278654dc41b1aefe273a0489368585856040516109fc93929190616a9a565b60405180910390a150506001600055505050565b60026000541415610a335760405162461bcd60e51b8152600401610518906177e3565b600260005585610a4281612ae3565b8351855114610a635760405162461bcd60e51b815260040161051890616cf1565b6060610a6f8887612d4f565b9050606080610a828a89858c8b8a612df6565b915091506060885167ffffffffffffffff81118015610aa057600080fd5b50604051908082528060200260200182016040528015610aca578160200160208202803683370190505b50905060005b8951811015610bee5760008a8281518110610ae757fe5b602002602001015190506000610b0f868481518110610b0257fe5b6020026020010151612eef565b90508a8381518110610b1d57fe5b6020026020010151816001600160801b03161115610b4d5760405162461bcd60e51b815260040161051890617043565b610b598282338d612f25565b6000610b6a868581518110610b0257fe5b6001600160a01b038416600090815260026020526040902054909150610b99906001600160801b038316613010565b6001600160a01b038416600090815260026020526040902055610bc86001600160801b03808416908316613035565b858581518110610bd457fe5b602002602001018181525050505050806001019050610ad0565b506000610bfa8c612b75565b90506002816002811115610c0a57fe5b1415610c7257610c6d8c8b600081518110610c2157fe5b602002602001015184600081518110610c3657fe5b60200260200101518d600181518110610c4b57fe5b602002602001015186600181518110610c6057fe5b602002602001015161307b565b610c9c565b6001816002811115610c8057fe5b1415610c9157610c6d8c8b846130c6565b610c9c8c8b84613130565b336001600160a01b03168c7ff7f95732a0f83c5093bfd147b3c8e57ac41ee39cd0f23cb6e74325e9f8fe1a648686604051610cd8929190616a12565b60405180910390a35050600160005550505050505050505050565b606080610d4c610d02876104f0565b868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250610d4592505050368790038701876164f7565b60006131a7565b90506001600160a01b03891615610ddd576040517f9ab681f20000000000000000000000000000000000000000000000000000000081526001600160a01b038a1690639ab681f290610daa908890889086908e908e9060040161686c565b600060405180830381600087803b158015610dc457600080fd5b505af1158015610dd8573d6000803e3d6000fd5b505050505b98975050505050505050565b6060828210158015610e065750610e00600b612a7a565b83830311155b610e225760405162461bcd60e51b8152600401610518906172b3565b606083830367ffffffffffffffff81118015610e3d57600080fd5b50604051908082528060200260200182016040528015610e67578160200160208202803683370190505b50905060005b81518110156107e957610e83600b8287016133ea565b828281518110610e8f57fe5b6020908102919091010152600101610e6d565b60026000541415610ec55760405162461bcd60e51b8152600401610518906177e3565b6002600055610ed2612038565b6001600160a01b031663026158d5336040518263ffffffff1660e01b8152600401610efd9190616796565b60206040518083038186803b158015610f1557600080fd5b505afa158015610f29573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f4d9190616146565b610f695760405162461bcd60e51b8152600401610518906173c6565b7f00000000000000000000000000000000000000000000000000000000000000006001600160801b0316811115610fb25760405162461bcd60e51b81526004016105189061738f565b610fbb81612eef565b600380546fffffffffffffffffffffffffffffffff19166001600160801b0392909216919091179055506001600055565b6060611004610ffa866104f0565b85858560016133f6565b95945050505050565b606061100461101b866104f0565b85858560006133f6565b600260005414156110485760405162461bcd60e51b8152600401610518906177e3565b6002600055611055612038565b6001600160a01b0316637c3b47f5336040518263ffffffff1660e01b81526004016110809190616796565b60206040518083038186803b15801561109857600080fd5b505afa1580156110ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110d09190616146565b6110ec5760405162461bcd60e51b8152600401610518906171ea565b7f00000000000000000000000000000000000000000000000000000000000000006001600160801b03168111156111355760405162461bcd60e51b8152600401610518906170b1565b61113e81612eef565b600380546001600160801b03928316700100000000000000000000000000000000029216919091179055506001600055565b600260005414156111935760405162461bcd60e51b8152600401610518906177e3565b600260005582826111a482826134ac565b60006111af86612b75565b905060018160028111156111bf57fe5b14156111dd576111d886866111d387612eef565b613502565b611217565b60028160028111156111eb57fe5b1415611204576111d886866111ff87612eef565b613515565b611217868661121287612eef565b613523565b61122b6001600160a01b0386163386613531565b6001600160a01b03851633877fea86d22f498d42c4c5ed8d09366d0af8bb816a7d2265eef1080d0cb6acb517bb611261886135b4565b60405161126e9190616a25565b60405180910390a45050600160005550505050565b600260005414156112a65760405162461bcd60e51b8152600401610518906177e3565b600260005582518451146112cc5760405162461bcd60e51b815260040161051890616ead565b6060845167ffffffffffffffff811180156112e657600080fd5b50604051908082528060200260200182016040528015611310578160200160208202803683370190505b5090506060855167ffffffffffffffff8111801561132d57600080fd5b50604051908082528060200260200182016040528015611357578160200160208202803683370190505b50905060005b86518110156114d35786818151811061137257fe5b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016113a59190616796565b60206040518083038186803b1580156113bd57600080fd5b505afa1580156113d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113f5919061654c565b82828151811061140157fe5b60200260200101818152505085818151811061141957fe5b602002602001015182828151811061142d57fe5b602002602001015110156114535760405162461bcd60e51b8152600401610518906176f2565b61146f86828151811061146257fe5b60200260200101516135f5565b83828151811061147b57fe5b6020026020010181815250506114cb8887838151811061149757fe5b60200260200101518984815181106114ab57fe5b60200260200101516001600160a01b03166135319092919063ffffffff16565b60010161135d565b506040517ff04f27070000000000000000000000000000000000000000000000000000000081526001600160a01b0388169063f04f270790611521908990899087908a908a906004016168cc565b600060405180830381600087803b15801561153b57600080fd5b505af115801561154f573d6000803e3d6000fd5b5050505060005b86518110156116d857600087828151811061156d57fe5b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016115a09190616796565b60206040518083038186803b1580156115b857600080fd5b505afa1580156115cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115f0919061654c565b9050600061161a84848151811061160357fe5b60200260200101518361360c90919063ffffffff16565b905084838151811061162857fe5b602002602001015181101561164f5760405162461bcd60e51b81526004016105189061700c565b61169a81600260008c878151811061166357fe5b60200260200101516001600160a01b03166001600160a01b031681526020019081526020016000205461301090919063ffffffff16565b600260008b86815181106116aa57fe5b6020908102919091018101516001600160a01b03168252810191909152604001600020555050600101611556565b50506001600055505050505050565b6002600054141561170a5760405162461bcd60e51b8152600401610518906177e3565b60026000558461171981612b37565b600061172487612b75565b9050600281600281111561173457fe5b14156117ac576002851461175a5760405162461bcd60e51b815260040161051890617145565b6117a7878787600081811061176b57fe5b90506020020160208101906117809190615e03565b8888600181811061178d57fe5b90506020020160208101906117a29190615e03565b61363d565b61183a565b60018160028111156117ba57fe5b14156117fd576117a7878787808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506137a392505050565b61183a8787878080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061383c92505050565b60005b8581101561191857600085858381811061185357fe5b90506020020160208101906118689190615e03565b9050600088888481811061187857fe5b905060200201602081019061188d9190615e03565b60008b8152600d602090815260408083206001600160a01b038581168086529190935281842080547fffffffffffffffffffffffff00000000000000000000000000000000000000001693881693841790559051939450909290918d917fc438982f36308c6c0153761eaa0cf9f00a59ef4d93338c934468f52bd45296119190a4505060010161183d565b507fb69d13ab78b4f721123e9de02f1779b42ef54bb914fd86024b5a85c4fadfee8887878760405161194c93929190616a9a565b60405180910390a1505060016000555050505050565b600260005414156119855760405162461bcd60e51b8152600401610518906177e3565b6002600055828261199682826134ac565b60006119a186612b75565b905060018160028111156119b157fe5b14156119cf576119ca86866119c587612eef565b6138d6565b611a09565b60028160028111156119dd57fe5b14156119f6576119ca86866119f187612eef565b6138e4565b611a098686611a0487612eef565b6138f2565b5050600160005550505050565b60026000541415611a395760405162461bcd60e51b8152600401610518906177e3565b600260005585611a4881612ae3565b8351855114611a695760405162461bcd60e51b815260040161051890616cf1565b6060611a758887612d4f565b9050606080611a888a89858c8b8a613900565b915091506060885167ffffffffffffffff81118015611aa657600080fd5b50604051908082528060200260200182016040528015611ad0578160200160208202803683370190505b50905060005b8951811015611be75760008a8281518110611aed57fe5b602002602001015190506000611b08868481518110610b0257fe5b90508a8381518110611b1657fe5b6020026020010151816001600160801b03161015611b465760405162461bcd60e51b815260040161051890616dbc565b611b5282828f8d6139cc565b6000611b63868581518110610b0257fe5b6001600160a01b038416600090815260026020526040902054909150611b92906001600160801b038316613010565b6001600160a01b038416600090815260026020526040902055611bc16001600160801b03838116908316613010565b858581518110611bcd57fe5b602002602001018181525050505050806001019050611ad6565b506000611bf38c612b75565b90506002816002811115611c0357fe5b1415611c6157611c5c8c8b600081518110611c1a57fe5b6020026020010151611c3285600081518110610b0257fe5b8d600181518110611c3f57fe5b6020026020010151611c5787600181518110610b0257fe5b613aed565b611c8b565b6001816002811115611c6f57fe5b1415611c8057611c5c8c8b84613afd565b611c8b8c8b84613b46565b336001600160a01b03168c7fe1f0410ab343b6bd5ac108e2e4c8085cef471896ef5214b73d944091850293218686604051610cd8929190616a12565b333014611ce65760405162461bcd60e51b815260040161051890616b5b565b6060611d3586868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250611d2f92505050368790038701876164f7565b85613b9c565b905080604051602001611d48919061691a565b60408051601f198184030181529082905262461bcd60e51b825261051891600401616ab4565b6000611d7a600b612a7a565b905090565b60026000541415611da25760405162461bcd60e51b8152600401610518906177e3565b60026000558151835114611dc85760405162461bcd60e51b815260040161051890617786565b60005b8351811015611f6d576000848281518110611de257fe5b6020908102919091018101513360009081526005835260408082206001600160a01b03841683529093529182205486519193506001600160801b03169190611e3090879086908110610b0257fe5b9050816001600160801b0316816001600160801b03161115611e645760405162461bcd60e51b815260040161051890616b92565b3360009081526005602081815260408084206001600160a01b0388811680875291845282862080546fffffffffffffffffffffffffffffffff1916888a036001600160801b0390811691909117909155908b16865293835281852090855290915290912054611ed4911682613e4d565b6001600160a01b038681166000818152600560209081526040808320948916808452949091529081902080546fffffffffffffffffffffffffffffffff19166001600160801b039590951694909417909355915190919033907fc9427b4a5655c5832a046d33056c59e7191d43a22bd8f93c89277f33efaf45fd90611f5a9086906178bd565b60405180910390a4505050600101611dcb565b505060016000555050565b60008083611f8581612ae3565b600080611f9187612b75565b90506002816002811115611fa157fe5b1415611fb857611fb18787613e7e565b9150611fe3565b6001816002811115611fc657fe5b1415611fd657611fb18787613f6a565b611fe08787613fd4565b91505b611fec82613ff4565b6001600160801b0316945061200082614000565b6001600160801b031693505050509250929050565b60035470010000000000000000000000000000000090046001600160801b031690565b6001546001600160a01b031690565b60045490565b600260005414156120705760405162461bcd60e51b8152600401610518906177e3565b600260005581518351146120965760405162461bcd60e51b815260040161051890617786565b60005b8351811015611f6d5760008482815181106120b057fe5b6020026020010151905060006120cb858481518110610b0257fe5b3360009081526005602090815260408083206001600160a01b03871684529091529020549091506001600160801b0390811690821681101561211f5760405162461bcd60e51b815260040161051890616c5d565b3360009081526005602090815260408083206001600160a01b0387168452909152812080546fffffffffffffffffffffffffffffffff19168484036001600160801b031617905561216f83614006565b6001600160a01b03851660009081526002602052604090205490915061219e906001600160801b038316613010565b6001600160a01b0385166000908152600260205260409020556121e2866121d16001600160801b0386811690851661360c565b6001600160a01b0387169190613531565b836001600160a01b0316866001600160a01b0316336001600160a01b03167f7b875067eda472e508132da5f6930c3a6b21129bcb10c84169bbc72aec9eef7a8660405161222f91906178bd565b60405180910390a45050600190920191506120999050565b606080610d4c612256876104f0565b86868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061229992505050368790038701876164f7565b60016131a7565b600260005414156122c35760405162461bcd60e51b8152600401610518906177e3565b600260005582826122d482826134ac565b6122e96001600160a01b038516333086614022565b60006122f486612b75565b9050600181600281111561230457fe5b14156123225761231d868661231887612eef565b614043565b61235c565b600281600281111561233057fe5b14156123495761231d868661234487612eef565b614051565b61235c868661235787612eef565b61405f565b6001600160a01b03851633877fea86d22f498d42c4c5ed8d09366d0af8bb816a7d2265eef1080d0cb6acb517bb612392886135b4565b60000360405161126e9190616a25565b600260005414156123c55760405162461bcd60e51b8152600401610518906177e3565b600260005581518351146123eb5760405162461bcd60e51b815260040161051890617786565b60005b8351811015611f6d57600084828151811061240557fe5b60200260200101519050600084838151811061241d57fe5b6020026020010151905061246861243382612eef565b6001600160a01b038087166000908152600560209081526040808320938816835292905220546001600160801b031690613e4d565b6001600160a01b03858116600090815260056020908152604080832093871680845293909152902080546fffffffffffffffffffffffffffffffff19166001600160801b0393909316929092179091556124c490333084614022565b816001600160a01b0316846001600160a01b0316336001600160a01b03167fb76281916fe2a7c5a7b2c2d3b84fcc820d3b5546b3d3572a74840423fec96a7c846040516125119190616a25565b60405180910390a450506001016123ee565b600260005414156125465760405162461bcd60e51b8152600401610518906177e3565b6002600055612553612038565b6001600160a01b03166315e61d33336040518263ffffffff1660e01b815260040161257e9190616796565b60206040518083038186803b15801561259657600080fd5b505afa1580156125aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125ce9190616146565b6125ea5760405162461bcd60e51b8152600401610518906170e8565b7f000000000000000000000000000000000000000000000000000000000000000081111561262a5760405162461bcd60e51b815260040161051890616ac7565b61263381612eef565b6001600160801b0316600455506001600055565b6002600054141561266a5760405162461bcd60e51b8152600401610518906177e3565b600260005583821461268e5760405162461bcd60e51b815260040161051890616ead565b6000612698612038565b905060005b8581101561280e5760008787838181106126b357fe5b90506020020160208101906126c89190615e03565b6040517f75f101590000000000000000000000000000000000000000000000000000000081529091506001600160a01b038416906375f101599061271290339085906004016167aa565b60206040518083038186803b15801561272a57600080fd5b505afa15801561273e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127629190616146565b61277e5760405162461bcd60e51b815260040161051890616c00565b600086868481811061278c57fe5b9050602002013590508060026000846001600160a01b03166001600160a01b031681526020019081526020016000205410156127da5760405162461bcd60e51b81526004016105189061700c565b6001600160a01b038216600081815260026020526040902080548390039055612804908683613531565b505060010161269d565b505060016000555050505050565b6000808261282981612ae3565b6128328461406d565b61283b85612b75565b925092505b50915091565b6001600160a01b0381166000908152600260205260409020545b919050565b6060808261287281612ae3565b600061287d85612b75565b9050600281600281111561288d57fe5b14156128a65761289c85614073565b9350935050612840565b60018160028111156128b457fe5b14156128c35761289c85614236565b61289c85614366565b5050915091565b60008282026001600160801b038416158061291a5750826001600160801b0316846001600160801b0316826001600160801b03168161290e57fe5b046001600160801b0316145b6129365760405162461bcd60e51b815260040161051890617358565b6706f05b59d3b2000081016001600160801b03808316908216101561296d5760405162461bcd60e51b815260040161051890617358565b6000670de0b6b3a76400006001600160801b0383165b049695505050505050565b60006001600160801b0382166129b65760405162461bcd60e51b815260040161051890617423565b670de0b6b3a764000083026001600160801b03841615806129fc5750670de0b6b3a76400006001600160801b03858116908316816129f057fe5b046001600160801b0316145b612a185760405162461bcd60e51b81526004016105189061717c565b600060026001600160801b0385160482019050816001600160801b0316816001600160801b03161015612a5d5760405162461bcd60e51b81526004016105189061717c565b6000846001600160801b0316826001600160801b03168161298357fe5b60006107ed82614487565b600069ffffffffffffffffffff82166050846002811115612aa257fe5b901b17606085901b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000161790505b9392505050565b6000612ad0838361448b565b612aee600b826144d5565b612b0a5760405162461bcd60e51b815260040161051890616cba565b50565b612b1782826144e1565b612b335760405162461bcd60e51b815260040161051890617321565b5050565b612b4081612ae3565b6000612b4b8261406d565b90506001600160a01b0381163314612b335760405162461bcd60e51b81526004016105189061707a565b600061ffff605083901c1660028111156107ed57fe5b600080612b9985858561453d565b5091509150612ba7826145f5565b8015612bb75750612bb7816145f5565b612bd35760405162461bcd60e51b815260040161051890616d85565b50505060009182525060096020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000009081168255600190910180549091169055565b6000828152600760205260408120905b8251811015612ccd576000838281518110612c4257fe5b60209081029190910181015160008781526008835260408082206001600160a01b03841683529093529190912054909150612c7c906145f5565b612c985760405162461bcd60e51b815260040161051890616d85565b6000612ca484836145f9565b905080612cc35760405162461bcd60e51b815260040161051890617321565b5050600101612c2b565b50505050565b6000828152600660205260408120905b8251811015612ccd576000838281518110612cfa57fe5b602002602001015190506000612d10848361460e565b9050612d1b816145f5565b612d375760405162461bcd60e51b815260040161051890616d85565b612d41848361465a565b505050806001019050612ce3565b6060806060612d5d85612865565b915091508351825114612d825760405162461bcd60e51b8152600401610518906174c8565b60005b8251811015612ded57848181518110612d9a57fe5b60200260200101516001600160a01b0316838281518110612db757fe5b60200260200101516001600160a01b031614612de55760405162461bcd60e51b8152600401610518906174c8565b600101612d85565b50949350505050565b6060806000612e048961406d565b9050806001600160a01b0316630385ccea8a33898b8a612e22612015565b8b6040518863ffffffff1660e01b8152600401612e459796959493929190616a2e565b600060405180830381600087803b158015612e5f57600080fd5b505af1158015612e73573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612e9b91908101906160ef565b8951825192955090935014612ec25760405162461bcd60e51b815260040161051890616d4e565b8751825114612ee35760405162461bcd60e51b815260040161051890617638565b50965096945050505050565b60007001000000000000000000000000000000008210612f215760405162461bcd60e51b815260040161051890616df3565b5090565b6001600160801b038316612f3857612ccd565b828115612fdc576001600160a01b0380841660009081526005602090815260408083209389168352929052908120546001600160801b039081169190612f8a90612f85908490861661466f565b612eef565b6001600160a01b038681166000908152600560209081526040808320938c1683529290522080546fffffffffffffffffffffffffffffffff1916938290036001600160801b0316939093179092555090035b6001600160801b03811615613009576130096001600160a01b03861684306001600160801b038516614022565b5050505050565b600082820183811015612ad05760405162461bcd60e51b815260040161051890617601565b600081830381831280159061304a5750838113155b8061305f575060008312801561305f57508381135b612ad05760405162461bcd60e51b815260040161051890617695565b613009858561308c612f8587614685565b6000871361309c576146a16130a0565b6146d95b866130ad612f8588614685565b600088136130bd576146a16130c1565b6146d95b6146f8565b60005b8251811015612ccd5760008282815181106130e057fe5b60200260200101519050613127858584815181106130fa57fe5b602002602001015160008413613112576146a1613116565b6146d95b613122612f8586614685565b614785565b506001016130c9565b6000838152600660205260408120905b835181101561300957600083828151811061315757fe5b6020026020010151905061319e8386848151811061317157fe5b602002602001015160008413613189576146a161318d565b6146d95b613199612f8586614685565b6147cf565b50600101613140565b6060600260005414156131cc5760405162461bcd60e51b8152600401610518906177e3565b600260005560606131df86868686613b9c565b905060005b85518110156133db5760008682815181106131fb57fe5b60200260200101519050600083838151811061321357fe5b602002602001015113156132f557600083838151811061322f57fe5b602002602001015190508660200151156132d1573360009081526005602090815260408083206001600160a01b03861684529091528120546001600160801b039081169190613281908390851661466f565b3360009081526005602090815260408083206001600160a01b0389168452909152902080546fffffffffffffffffffffffffffffffff1916938290036001600160801b0316939093179092555090035b6132ef6001600160a01b03831633306001600160801b038516614022565b506133d2565b6000613316612f8585858151811061330957fe5b6020026020010151614685565b90508660400151156133b05786516001600160a01b0390811660009081526005602090815260408083209386168352929052205461335d906001600160801b031682613e4d565b87516001600160a01b03908116600090815260056020908152604080832093871683529290522080546fffffffffffffffffffffffffffffffff19166001600160801b03929092169190911790556133d0565b86516133d0906001600160a01b038416906001600160801b038416613531565b505b506001016131e4565b50600160005595945050505050565b6000612ad083836147ff565b6040517f75e9cfb700000000000000000000000000000000000000000000000000000000815260609030906375e9cfb79061343d908990899089908990899060040161692d565b600060405180830381600087803b15801561345757600080fd5b505af1925050508015613468575060015b6134aa57613474617972565b8061347f575061349b565b808060200190518101906134939190615f63565b9150506134a5565b3d6000803e3d6000fd5b611004565bfe5b6134b582612ae3565b6134bf8282612b0d565b6000828152600d602090815260408083206001600160a01b038581168552925290912054163314612b335760405162461bcd60e51b81526004016105189061781a565b613510838361484484614785565b505050565b613510838361484484614865565b61351083836148448461497f565b6135108363a9059cbb60e01b848460405160240161355092919061680f565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152614999565b60007f80000000000000000000000000000000000000000000000000000000000000008210612f215760405162461bcd60e51b81526004016105189061756d565b60006107ed60045483614a2890919063ffffffff16565b600080600061361b8585614a9a565b9150915080156107e95760405162461bcd60e51b8152600401610518906175ca565b6001600160a01b0382161580159061365d57506001600160a01b03811615155b6136795760405162461bcd60e51b81526004016105189061745a565b806001600160a01b0316826001600160a01b031614156136ab5760405162461bcd60e51b8152600401610518906171b3565b6136b3615a91565b50600083815260096020908152604091829020825180840190935280546001600160a01b039081168085526001909201541691830191909152158015613704575060208101516001600160a01b0316155b6137205760405162461bcd60e51b815260040161051890616f9e565b60008061372d8585614abf565b6040805180820182526001600160a01b039384168152918316602080840191825260009a8b52600990529820905181547fffffffffffffffffffffffff00000000000000000000000000000000000000009081169184169190911782559751600190910180549098169116179095555050505050565b6000828152600760205260408120905b8251811015612ccd5760008382815181106137ca57fe5b6020026020010151905060006001600160a01b0316816001600160a01b031614156138075760405162461bcd60e51b81526004016105189061745a565b60006138138483614af0565b9050806138325760405162461bcd60e51b8152600401610518906171b3565b50506001016137b3565b6000828152600660205260408120905b8251811015612ccd57600083828151811061386357fe5b6020026020010151905060006001600160a01b0316816001600160a01b031614156138a05760405162461bcd60e51b81526004016105189061745a565b60006138ad848383614b05565b9050806138cc5760405162461bcd60e51b8152600401610518906171b3565b505060010161384c565b6135108383614b1b84614785565b6135108383614b1b84614865565b6135108383614b1b8461497f565b606080600061390e8961406d565b9050806001600160a01b03166345c6472c8a33898b8a61392c612015565b8b6040518863ffffffff1660e01b815260040161394f9796959493929190616a2e565b600060405180830381600087803b15801561396957600080fd5b505af115801561397d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526139a591908101906160ef565b8951825192955090935014612ec25760405162461bcd60e51b815260040161051890616bc9565b6001600160801b0383166139df57612ccd565b8015613a6f576001600160a01b03808316600090815260056020908152604080832093881683529290522054613a1e906001600160801b031684613e4d565b6001600160a01b03838116600090815260056020908152604080832093891683529290522080546fffffffffffffffffffffffffffffffff19166001600160801b0392909216919091179055612ccd565b6000613a7a84614006565b6001600160a01b038616600090815260026020526040902054909150613aa9906001600160801b038316613010565b6001600160a01b03861660009081526002602052604090205561300983613adc6001600160801b0387811690851661360c565b6001600160a01b0388169190613531565b61300985858585856146a1614b33565b60005b8251811015612ccd576000613b1a838381518110610b0257fe5b9050613b3d85858481518110613b2c57fe5b60200260200101516146a184614785565b50600101613b00565b6000838152600660205260408120905b8351811015613009576000613b70848381518110610b0257fe5b9050613b9383868481518110613b8257fe5b60200260200101516146a1846147cf565b50600101613b56565b6060835167ffffffffffffffff81118015613bb657600080fd5b50604051908082528060200260200182016040528015613be0578160200160208202803683370190505b509050613beb615a91565b613bf3615aa8565b60005b8751811015613e4257878181518110613c0b57fe5b6020026020010151915086518260200151108015613c2d575086518260400151105b613c495760405162461bcd60e51b815260040161051890616f0a565b600087836020015181518110613c5b57fe5b60200260200101519050600088846040015181518110613c7757fe5b60200260200101519050806001600160a01b0316826001600160a01b03161415613cb35760405162461bcd60e51b8152600401610518906172ea565b6060840151613d3b5760018a511115613d23576000613cd3888484614bbf565b6001600160a01b031686600001516001600160a01b031614905080613d0a5760405162461bcd60e51b815260040161051890617491565b5060208501516001600160801b03166060850152613d3b565b60405162461bcd60e51b815260040161051890616fd5565b600080613d51848488338e600001518c8f614be1565b91509150613d7f88876020015181518110613d6857fe5b6020026020010151836001600160801b0316614cb8565b88876020015181518110613d8f57fe5b602002602001018181525050613dc588876040015181518110613dae57fe5b6020026020010151826001600160801b0316613035565b88876040015181518110613dd557fe5b602002602001018181525050826001600160a01b0316846001600160a01b031687600001517f2170c741c41531aec20e7c107c24eecfdd15e69c9bb0a8dd37b1840b9e0b207b8585604051613e2b9291906178d1565b60405180910390a450505050806001019050613bf6565b505050949350505050565b60008282016001600160801b038085169082161015612ad05760405162461bcd60e51b815260040161051890617601565b6000613e88615a91565b506000838152600960209081526040808320815180830190925280546001600160a01b0390811680845260019092015416928201839052909291613ecc9190614cfe565b6000868152600a60209081526040808320848452909152902080546001820154855193945091929091906001600160a01b0388811691161415613f1f57613f138282614d31565b955050505050506107ed565b84602001516001600160a01b0316876001600160a01b03161415613f4757613f138282614d4d565b60405162461bcd60e51b815260040161051890617321565b505050505092915050565b60008281526008602090815260408083206001600160a01b038516845290915281205481613f9782614d64565b80613fb557506000858152600760205260409020613fb59085614d76565b9050806107e95760405162461bcd60e51b815260040161051890617321565b6000828152600660205260408120613fec818461460e565b949350505050565b6001600160801b031690565b60801c90565b6003546000906107ed906001600160801b0384811691166128d3565b612ccd846323b872dd60e01b858585604051602401613550939291906167c4565b6135108383614d8b84614785565b6135108383614d8b84614865565b6135108383614d8b8461497f565b60601c90565b60608061407e615a91565b50600083815260096020908152604091829020825180840190935280546001600160a01b03908116808552600190920154169183019190915215806140ce575060208101516001600160a01b0316155b156140f2575050604080516000808252602082019081528183019092529150614231565b604080516002808252606082018352909160208301908036833701905050925080600001518360008151811061412457fe5b60200260200101906001600160a01b031690816001600160a01b03168152505080602001518360018151811061415657fe5b6001600160a01b039290921660209283029190910182015260408051600280825260608201835290929091908301908036833701905050915060006141a382600001518360200151614cfe565b6000868152600a6020908152604080832084845290915290208054600182015492935090916141da6141d58383614d31565b614dac565b6001600160801b0316866000815181106141f057fe5b6020026020010181815250506142096141d58383614d4d565b6001600160801b03168660018151811061421f57fe5b60200260200101818152505050505050505b915091565b6000818152600760205260409020606090819061425281612a7a565b67ffffffffffffffff8111801561426857600080fd5b50604051908082528060200260200182016040528015614292578160200160208202803683370190505b509250825167ffffffffffffffff811180156142ad57600080fd5b506040519080825280602002602001820160405280156142d7578160200160208202803683370190505b50915060005b83518110156128cc5760006142f283836133ea565b90508085838151811061430157fe5b6001600160a01b039283166020918202929092018101919091526000888152600882526040808220938516825292909152205461433d90614dac565b6001600160801b031684838151811061435257fe5b6020908102919091010152506001016142dd565b6000818152600660205260409020606090819061438281612a7a565b67ffffffffffffffff8111801561439857600080fd5b506040519080825280602002602001820160405280156143c2578160200160208202803683370190505b509250825167ffffffffffffffff811180156143dd57600080fd5b50604051908082528060200260200182016040528015614407578160200160208202803683370190505b50915060005b83518110156128cc576000806144238484614dc3565b915091508186848151811061443457fe5b60200260200101906001600160a01b031690816001600160a01b03168152505061445d81614dac565b6001600160801b031685848151811061447257fe5b6020908102919091010152505060010161440d565b5490565b60006144978383614ddf565b6144cd575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556107ed565b5060006107ed565b6000612ad08383614ddf565b6000806144ed84612b75565b905060028160028111156144fd57fe5b14156145155761450d8484614df7565b9150506107ed565b600181600281111561452357fe5b14156145335761450d8484614e78565b61450d8484614e90565b600080600080600061454f8787614abf565b91509150600061455f8383614cfe565b60008a8152600a602090815260408083208484529091528120805460018201549197509293509061458f83614d64565b8061459e575061459e82614d64565b806145af57506145af8c8787614ea8565b9050806145ce5760405162461bcd60e51b815260040161051890617321565b6145d88383614d31565b98506145e48383614d4d565b975050505050505093509350939050565b1590565b6000612ad0836001600160a01b038416614f19565b6000612ad0826040518060400160405280601881526020017f4552525f544f4b454e5f4e4f545f52454749535445524544000000000000000081525085614ffd9092919063ffffffff16565b6000612ad0836001600160a01b038416615013565b600081831061467e5781612ad0565b5090919050565b600080821315614696575080612860565b816000039050612860565b6000806146c0836146b186613ff4565b6001600160801b0316906150aa565b905060006146cd85614000565b905061100482826150b9565b6000806146c0836146e986613ff4565b6001600160801b031690613e4d565b60008060006147088a8a8861453d565b925092509250856001600160a01b0316896001600160a01b0316101561474d5761473683898963ffffffff16565b925061474682868663ffffffff16565b915061476e565b61475b83868663ffffffff16565b925061476b82898963ffffffff16565b91505b6147788383615115565b9055505050505050505050565b60006147918585613f6a565b90506147a181838563ffffffff16565b60009586526008602090815260408088206001600160a01b0390971688529590529390942092909255505050565b60006147db858561460e565b90506147f7846147ef83858763ffffffff16565b879190614b05565b505050505050565b815460009082106148225760405162461bcd60e51b815260040161051890616afe565b82600001828154811061483157fe5b9060005260206000200154905092915050565b600080614854836146b186613ff4565b905060006146cd846146e987614000565b61486d615a91565b506000848152600960209081526040808320815180830190925280546001600160a01b03908116808452600190920154169282018390529092916148b19190614cfe565b6000878152600a60209081526040808320848452909152812080546001820154939450909290916148e28383614d31565b905060006148f08484614d4d565b905086600001516001600160a01b03168a6001600160a01b031614156149255761491e82898b63ffffffff16565b9150614954565b86602001516001600160a01b03168a6001600160a01b03161415613f475761495181898b63ffffffff16565b90505b61495e8282615115565b855561496a8282615147565b85600101819055505050505050505050505050565b6000848152600660205260409020613009818585856147cf565b60606149ee826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166151669092919063ffffffff16565b8051909150156135105780806020019051810190614a0c9190616146565b6135105760405162461bcd60e51b815260040161051890617729565b6000828202831580614a42575082848281614a3f57fe5b04145b614a5e5760405162461bcd60e51b815260040161051890617358565b6706f05b59d3b20000810181811015614a895760405162461bcd60e51b815260040161051890617358565b6000670de0b6b3a764000082612983565b600080828410614ab05750508082036000614ab8565b505081810360015b9250929050565b600080826001600160a01b0316846001600160a01b031610614ae2578284614ae5565b83835b915091509250929050565b6000612ad0836001600160a01b03841661448b565b6000613fec846001600160a01b03851684615175565b600080614b2784613ff4565b9050613fec81846150b9565b6000806000614b4389898861453d565b925092509250856001600160a01b0316886001600160a01b03161015614b8857614b7183888663ffffffff16565b9250614b8182868663ffffffff16565b9150614ba9565b614b9683868663ffffffff16565b9250614ba682888663ffffffff16565b91505b614bb38383615115565b90555050505050505050565b600080846001811115614bce57fe5b14614bd95781613fec565b509092915050565b6000806000614bf38860600151612eef565b9050614bfd615ada565b6040518060e001604052808c6001600160a01b031681526020018b6001600160a01b03168152602001836001600160801b031681526020018a600001518152602001896001600160a01b03168152602001886001600160a01b031681526020018a6080015181525090506000614c738287615216565b9050614c80868d8d615291565b6001600160a01b031687526001600160801b0381166020880152614ca58684836152b2565b909d909c509a5050505050505050505050565b6000828201818312801590614ccd5750838112155b80614ce25750600083128015614ce257508381125b612ad05760405162461bcd60e51b815260040161051890616e50565b60008282604051602001614d1392919061675c565b60405160208183030381529060405280519060200120905092915050565b6000612ad0614d3f84614000565b614d4884614000565b6150b9565b6000612ad0614d5b84613ff4565b614d4884613ff4565b6000614d6f826145f5565b1592915050565b6000612ad0836001600160a01b038416614ddf565b600080614d9b836146e986613ff4565b905060006146cd846146b187614000565b60006107ed614dba83614000565b6146e984613ff4565b6000808080614dd286866152e0565b9097909650945050505050565b60009081526001919091016020526040902054151590565b6000614e01615a91565b50600083815260096020908152604091829020825180840190935280546001600160a01b039081168085526001909201548116928401929092529084161480614e5f575080602001516001600160a01b0316836001600160a01b0316145b8015613fec575050506001600160a01b03161515919050565b6000828152600760205260408120613fec8184614d76565b6000828152600660205260408120613fec81846152fa565b6000614eb2615a91565b50600084815260096020908152604091829020825180840190935280546001600160a01b03908116808552600190920154811692840192909252908516148015611004575080602001516001600160a01b0316836001600160a01b03161495945050505050565b60008181526001830160205260408120548015614ff35783547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8083019190810190600090879083908110614f6a57fe5b9060005260206000200154905080876000018481548110614f8757fe5b600091825260208083209091019290925582815260018981019092526040902090840190558654879080614fb757fe5b600190038181906000526020600020016000905590558660010160008781526020019081526020016000206000905560019450505050506107ed565b60009150506107ed565b6000613fec846001600160a01b0385168461530f565b60008181526002830160205260408120548015614ff35783547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90810160008181526001808801602090815260408084209587018452808420865481558684018054918501919091558654855260028b019092528084209690965593829055928190559086558481529182209190915590506107ed565b600080600061361b8585615329565b60008282016001600160801b0380851690821610156150ea5760405162461bcd60e51b8152600401610518906174ff565b50506fffffffffffffffffffffffffffffffff19608082901b166001600160801b0383161792915050565b600061512082613ff4565b6001600160801b0316608061513485613ff4565b6001600160801b0316901b019392505050565b600061515282614000565b6001600160801b0316608061513485614000565b6060613fec8484600085615351565b6000828152600284016020526040812054806151d85750508254604080518082018252848152602080820185815260008581526001808a018452858220945185559151938201939093559384018088558683526002880190915291902055612ad0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016000908152600180860160205260408220018390559050612ad0565b600080615226846060015161406d565b905060006152378560600151612b75565b9050600181600281111561524757fe5b141561525f57615258858386615412565b9250615289565b600281600281111561526d57fe5b141561527e576152588583866155c9565b611004858386615728565b505092915050565b6000808460018111156152a057fe5b146152ab5782613fec565b5092915050565b600080808560018111156152c257fe5b14156152d25750829050816152d8565b50819050825b935093915050565b600090815260019182016020526040902080549101549091565b6000612ad0836001600160a01b038416615984565b60008061531d85858561599c565b905061100485826159f7565b600080826001600160801b0316846001600160801b031610614ab05750508082036000614ab8565b6060824710156153735760405162461bcd60e51b815260040161051890616f41565b61537c85615a0d565b6153985760405162461bcd60e51b815260040161051890617536565b60006060866001600160a01b031685876040516153b59190616740565b60006040518083038185875af1925050503d80600081146153f2576040519150601f19603f3d011682016040523d82523d6000602084013e6153f7565b606091505b5091509150615407828286615a13565b979650505050505050565b60008061542785606001518660000151613f6a565b9050600061543d86606001518760200151613f6a565b9050600061544a83614dac565b9050600061545783614dac565b9050600086600181111561546757fe5b141561552b5760006154fc886001600160a01b0316633d28000161548a8c615a4c565b86866040518463ffffffff1660e01b81526004016154aa9392919061788a565b602060405180830381600087803b1580156154c457600080fd5b505af11580156154d8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f85919061654c565b905061551561550e8a60400151612eef565b86906146d9565b945061552184826146a1565b9095509250615573565b6000615548886001600160a01b03166395dc27ee61548a8c615a4c565b905061555485826146d9565b945061556d6155668a60400151612eef565b85906146a1565b90955092505b505060608601805160009081526008602081815260408084208b516001600160a01b0390811686529083528185209790975593518352908152828220988101519094168152969092529420939093555090919050565b6000806000806155e687606001518860000151896020015161453d565b92509250925060008088602001516001600160a01b031689600001516001600160a01b0316101561561b575083905082615621565b50829050835b600061562c83614dac565b9050600061563983614dac565b9050600089600181111561564957fe5b141561569457600061566c8b6001600160a01b0316633d28000161548a8f615a4c565b905061567e61550e8d60400151612eef565b945061568a84826146a1565b90985092506156d5565b60006156b18b6001600160a01b03166395dc27ee61548a8f615a4c565b90506156bd85826146d9565b94506156cf6155668d60400151612eef565b90985092505b60008b602001516001600160a01b03168c600001516001600160a01b0316101561570a576157038585615115565b9050615717565b6157148486615115565b90505b909455509498975050505050505050565b6060830151600090815260066020908152604080832086518251808401909352601883527f4552525f544f4b454e5f4e4f545f5245474953544552454400000000000000009383019390935283928392839161578691849190615a54565b905060006157d889602001516040518060400160405280601881526020017f4552525f544f4b454e5f4e4f545f52454749535445524544000000000000000081525085615a549092919063ffffffff16565b905060606157e584612a7a565b67ffffffffffffffff811180156157fb57600080fd5b50604051908082528060200260200182016040528015615825578160200160208202803683370190505b50805190915060005b818110156158935760006158428783615a6a565b905061584d81614dac565b6001600160801b031684838151811061586257fe5b6020026020010181815250508582141561587e5780985061588a565b8482141561588a578097505b5060010161582e565b5060008960018111156158a257fe5b14156159175760006158e78b6001600160a01b03166363df3b436158c58f615a4c565b8689896040518563ffffffff1660e01b81526004016154aa9493929190617851565b90508098506159036158fc8d60400151612eef565b89906146d9565b975061590f87826146a1565b965050615960565b60006159348b6001600160a01b031663a9a3f0376158c58f615a4c565b985088905061594388826146d9565b975061595c6159558d60400151612eef565b88906146a1565b9650505b61596b858589615a76565b615976858488615a76565b505050505050509392505050565b60009081526002919091016020526040902054151590565b600082815260028401602052604081205482816159cc5760405162461bcd60e51b81526004016105189190616ab4565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01949350505050565b6000908152600191820160205260409020015490565b3b151590565b60608315615a22575081612ad0565b825115615a325782518084602001fd5b8160405162461bcd60e51b81526004016105189190616ab4565b612f21615ada565b6000613fec846001600160a01b0385168461599c565b6000612ad083836159f7565b60008281526001808501602052604090912001819055613510565b604080518082019091526000808252602082015290565b6040518060a0016040528060008019168152602001600081526020016000815260200160008152602001606081525090565b6040805160e08101825260008082526020820181905291810182905260608082018390526080820183905260a082019290925260c081019190915290565b60008083601f840112615b29578182fd5b50813567ffffffffffffffff811115615b40578182fd5b6020830191508360208083028501011115614ab857600080fd5b600082601f830112615b6a578081fd5b8135615b7d615b7882617920565b6178f9565b818152915060208083019084810181840286018201871015615b9e57600080fd5b60005b84811015613f5f578135615bb481617a35565b84529282019290820190600101615ba1565b600082601f830112615bd6578081fd5b8135615be4615b7882617920565b818152915060208083019084810160005b84811015613f5f578135870160a080601f19838c03011215615c1657600080fd5b615c1f816178f9565b85830135815260408084013587830152606080850135828401526080915081850135818401525082840135925067ffffffffffffffff831115615c6157600080fd5b615c6f8c8885870101615d83565b90820152865250509282019290820190600101615bf5565b600082601f830112615c97578081fd5b8135615ca5615b7882617920565b818152915060208083019084810181840286018201871015615cc657600080fd5b60005b84811015613f5f57813584529282019290820190600101615cc9565b600082601f830112615cf5578081fd5b8151615d03615b7882617920565b818152915060208083019084810181840286018201871015615d2457600080fd5b60005b84811015613f5f57815184529282019290820190600101615d27565b60008083601f840112615d54578182fd5b50813567ffffffffffffffff811115615d6b578182fd5b602083019150836020828501011115614ab857600080fd5b600082601f830112615d93578081fd5b813567ffffffffffffffff811115615da9578182fd5b615dbc6020601f19601f840116016178f9565b9150808252836020828501011115615dd357600080fd5b8060208401602084013760009082016020015292915050565b600060608284031215615dfd578081fd5b50919050565b600060208284031215615e14578081fd5b8135612ad081617a35565b60008060408385031215615e31578081fd5b8235615e3c81617a35565b9150602083013567ffffffffffffffff811115615e57578182fd5b615e6385828601615b5a565b9150509250929050565b600080600080600060608688031215615e84578081fd5b853567ffffffffffffffff80821115615e9b578283fd5b615ea789838a01615b18565b90975095506020880135915080821115615ebf578283fd5b50615ecc88828901615b18565b9094509250506040860135615ee081617a35565b809150509295509295909350565b600080600060608486031215615f02578081fd5b833567ffffffffffffffff80821115615f19578283fd5b615f2587838801615b5a565b94506020860135915080821115615f3a578283fd5b50615f4786828701615c87565b9250506040840135615f5881617a35565b809150509250925092565b60006020808385031215615f75578182fd5b825167ffffffffffffffff811115615f8b578283fd5b8301601f81018513615f9b578283fd5b8051615fa9615b7882617920565b8181528381019083850185840285018601891015615fc5578687fd5b8694505b83851015615fe7578051835260019490940193918501918501615fc9565b50979650505050505050565b60008060008060a08587031215616008578182fd5b843567ffffffffffffffff8082111561601f578384fd5b61602b88838901615bc6565b95506020870135915080821115616040578384fd5b5061604d87828801615b18565b909450925061606190508660408701615dec565b905092959194509250565b600080600080600060c08688031215616083578283fd5b853567ffffffffffffffff8082111561609a578485fd5b6160a689838a01615bc6565b965060208801359150808211156160bb578485fd5b506160c888828901615b18565b90955093506160dc90508760408801615dec565b915060a086013560028110615ee0578182fd5b60008060408385031215616101578182fd5b825167ffffffffffffffff80821115616118578384fd5b61612486838701615ce5565b93506020850151915080821115616139578283fd5b50615e6385828601615ce5565b600060208284031215616157578081fd5b8151612ad081617a4a565b600060208284031215616173578081fd5b5035919050565b60008060008060008060c08789031215616192578384fd5b8635955060208701356161a481617a35565b9450604087013567ffffffffffffffff808211156161c0578586fd5b6161cc8a838b01615b5a565b955060608901359150808211156161e1578283fd5b6161ed8a838b01615c87565b9450608089013591506161ff82617a4a565b90925060a08801359080821115616214578283fd5b5061622189828a01615d83565b9150509295509295509295565b600080600060408486031215616242578081fd5b83359250602084013567ffffffffffffffff81111561625f578182fd5b61626b86828701615b18565b9497909650939450505050565b60008060008060006060868803121561628f578283fd5b85359450602086013567ffffffffffffffff808211156162ad578485fd5b6162b989838a01615b18565b909650945060408801359150808211156162d1578283fd5b506162de88828901615b18565b969995985093965092949392505050565b60008060408385031215616301578182fd5b82359150602083013561631381617a35565b809150509250929050565b600080600060608486031215616332578081fd5b83359250602084013561634481617a35565b929592945050506040919091013590565b60008060008060006080868803121561636c578283fd5b853561637781617a35565b9450602086013567ffffffffffffffff80821115616393578485fd5b61639f89838a01615b5a565b955060408801359150808211156163b4578485fd5b6163c089838a01615c87565b945060608801359150808211156163d5578283fd5b506162de88828901615d43565b600080600080600080600060e0888a0312156163fc578485fd5b873561640781617a35565b9650602088013567ffffffffffffffff80821115616423578687fd5b61642f8b838c01615d43565b909850965060408a0135915080821115616447578283fd5b6164538b838c01615bc6565b955060608a0135915080821115616468578283fd5b506164758a828b01615b18565b909450925061648990508960808a01615dec565b905092959891949750929550565b600080600080600080600060e0888a0312156164b1578081fd5b87356164bc81617a35565b9650602088013567ffffffffffffffff80821115616423578283fd5b6000602082840312156164e9578081fd5b813560038110612ad0578182fd5b600060608284031215616508578081fd5b61651260606178f9565b823561651d81617a35565b8152602083013561652d81617a4a565b6020820152604083013561654081617a4a565b60408201529392505050565b60006020828403121561655d578081fd5b5051919050565b60008060408385031215616576578182fd5b50508035926020909101359150565b60008284526020808501945082825b858110156165c25781356165a781617a35565b6001600160a01b031687529582019590820190600101616594565b509495945050505050565b6000815180845260208085019450808401835b838110156165c25781516001600160a01b0316875295820195908201906001016165e0565b6000815180845260208085019450808401835b838110156165c257815187529582019590820190600101616618565b60008284528282602086013780602084860101526020601f19601f85011685010190509392505050565b60008151808452616676816020860160208601617940565b601f01601f19169290920160200192915050565b6002811061669457fe5b9052565b80356166a381617a35565b6001600160a01b0316825260208101356166bc81617a4a565b1515602083015260408101356166d181617a4a565b8015156040840152505050565b60006001600160a01b0380835116845280602084015116602085015260408301516040850152606083015160608501528060808401511660808501528060a08401511660a08501525060c082015160e060c0850152613fec60e085018261665e565b60008251616752818460208701617940565b9190910192915050565b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606093841b811682529190921b16601482015260280190565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b0383168152604081016003831061680257fe5b8260208301529392505050565b6001600160a01b03929092168252602082015260400190565b6020808252825182820181905260009190848201906040850190845b8181101561686057835183529284019291840191600101616844565b50909695505050505050565b600060608252616880606083018789616585565b82810360208401526168928187616605565b90508281036040840152610ddd818587616634565b6000604082526168ba60408301856165cd565b82810360208401526110048185616605565b6000608082526168df60808301886165cd565b82810360208401526168f18188616605565b905082810360408401526169058187616605565b90508281036060840152610ddd818587616634565b600060208252612ad06020830184616605565b600060c0820160c0835280885180835260e0850191506020925060e0838202860101838b01855b838110156169d4578783037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff200185528151805184528681015187850152604080820151908501526060808201519085015260809081015160a0918501829052906169c08186018361665e565b968801969450505090850190600101616954565b5050858103848701526169e8818a8c616585565b9450505050506169fb6040830185616698565b616a0860a083018461668a565b9695505050505050565b6000604082526168ba6040830185616605565b90815260200190565b60008882526001600160a01b03808916602084015280881660408401525060e06060830152616a6060e0830187616605565b8281036080840152616a728187616605565b90508460a084015282810360c0840152616a8c818561665e565b9a9950505050505050505050565b600084825260406020830152611004604083018486616585565b600060208252612ad0602083018461665e565b60208082526016908201527f466c6173684c6f616e2066656520746f6f206869676800000000000000000000604082015260600190565b60208082526022908201527f456e756d657261626c655365743a20696e646578206f7574206f6620626f756e60408201527f6473000000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526017908201527f43616c6c6572206973206e6f7420746865205661756c74000000000000000000604082015260600190565b6020808252601f908201527f4552525f4e4f545f454e4f5547485f494e5445524e414c5f42414c414e434500604082015260600190565b60208082526016908201527f4552525f414d4f554e54535f4f55545f4c454e47544800000000000000000000604082015260600190565b60208082526024908201527f43616c6c65722063616e6e6f742077697468647261772070726f746f636f6c2060408201527f6665657300000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526026908201527f5661756c743a20776974686472617720616d6f756e742065786365656473206260408201527f616c616e63650000000000000000000000000000000000000000000000000000606082015260800190565b60208082526010908201527f4e6f6e6578697374656e7420706f6f6c00000000000000000000000000000000604082015260600190565b60208082526022908201527f4552525f544f4b454e535f414d4f554e54535f4c454e4754485f4d49534d415460408201527f4348000000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526015908201527f4552525f414d4f554e54535f494e5f4c454e4754480000000000000000000000604082015260600190565b6020808252601d908201527f4552525f544f4b454e5f42414c414e43455f49535f4e4f545f5a45524f000000604082015260600190565b60208082526012908201527f4552525f455849545f42454c4f575f4d494e0000000000000000000000000000604082015260600190565b60208082526027908201527f53616665436173743a2076616c756520646f65736e27742066697420696e203160408201527f3238206269747300000000000000000000000000000000000000000000000000606082015260800190565b60208082526021908201527f5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f60408201527f7700000000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526022908201527f546f6b656e7320616e6420616d6f756e7473206c656e677468206d69736d617460408201527f6368000000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526017908201527f4552525f494e4445585f4f55545f4f465f424f554e4453000000000000000000604082015260600190565b60208082526026908201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60408201527f722063616c6c0000000000000000000000000000000000000000000000000000606082015260800190565b60208082526016908201527f4552525f544f4b454e535f414c52454144595f53455400000000000000000000604082015260600190565b6020808252601f908201527f556e6b6e6f776e20616d6f756e7420696e206f6e206669727374207377617000604082015260600190565b6020808252601a908201527f496e73756666696369656e742070726f746f636f6c2066656573000000000000604082015260600190565b60208082526012908201527f4552525f4a4f494e5f41424f56455f4d41580000000000000000000000000000604082015260600190565b60208082526016908201527f43616c6c6572206973206e6f742074686520706f6f6c00000000000000000000604082015260600190565b60208082526011908201527f537761702066656520746f6f2068696768000000000000000000000000000000604082015260600190565b60208082526029908201527f43616c6c65722063616e6e6f74207365742070726f746f636f6c20666c61736860408201527f206c6f616e206665650000000000000000000000000000000000000000000000606082015260800190565b6020808252601b908201527f4552525f544f4b454e535f4c454e4754485f4d5553545f42455f320000000000604082015260600190565b60208082526010908201527f4552525f4449565f494e5445524e414c00000000000000000000000000000000604082015260600190565b6020808252601c908201527f4552525f544f4b454e5f414c52454144595f5245474953544552454400000000604082015260600190565b60208082526023908201527f43616c6c65722063616e6e6f74207365742070726f746f636f6c20737761702060408201527f6665650000000000000000000000000000000000000000000000000000000000606082015260800190565b6020808252818101527f43616c6c65722063616e6e6f74207472616e7366657220617574686f72697479604082015260600190565b60208082526016908201527f506f6f6c20494420616c72656164792065786973747300000000000000000000604082015260600190565b6020808252600f908201527f4552525f4241445f494e44494345530000000000000000000000000000000000604082015260600190565b60208082526013908201527f5377617020666f722073616d6520746f6b656e00000000000000000000000000604082015260600190565b60208082526018908201527f4552525f544f4b454e5f4e4f545f524547495354455245440000000000000000604082015260600190565b60208082526010908201527f4552525f4d554c5f4f564552464c4f5700000000000000000000000000000000604082015260600190565b60208082526015908201527f57697468647261772066656520746f6f20686967680000000000000000000000604082015260600190565b60208082526027908201527f43616c6c65722063616e6e6f74207365742070726f746f636f6c20776974686460408201527f7261772066656500000000000000000000000000000000000000000000000000606082015260800190565b6020808252600c908201527f4552525f4449565f5a45524f0000000000000000000000000000000000000000604082015260600190565b60208082526016908201527f4552525f544f4b454e5f43414e545f42455f5a45524f00000000000000000000604082015260600190565b6020808252601c908201527f4d6973636f6e7374727563746564206d756c7469686f70207377617000000000604082015260600190565b60208082526013908201527f4552525f544f4b454e535f4d49534d4154434800000000000000000000000000604082015260600190565b60208082526016908201527f42414c414e43455f544f54414c5f4f564552464c4f5700000000000000000000604082015260600190565b6020808252601d908201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604082015260600190565b60208082526028908201527f53616665436173743a2076616c756520646f65736e27742066697420696e206160408201527f6e20696e74323536000000000000000000000000000000000000000000000000606082015260800190565b60208082526011908201527f4552525f5355425f554e444552464c4f57000000000000000000000000000000604082015260600190565b60208082526010908201527f4552525f4144445f4f564552464c4f5700000000000000000000000000000000604082015260600190565b60208082526023908201527f4552525f4455455f50524f544f434f4c5f4645455f414d4f554e54535f4c454e60408201527f4754480000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526024908201527f5369676e6564536166654d6174683a207375627472616374696f6e206f76657260408201527f666c6f7700000000000000000000000000000000000000000000000000000000606082015260800190565b6020808252601e908201527f496e73756666696369656e742062616c616e636520746f20626f72726f770000604082015260600190565b6020808252602a908201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60408201527f6f74207375636365656400000000000000000000000000000000000000000000606082015260800190565b60208082526029908201527f5661756c743a20746f6b656e7320616e6420616d6f756e7473206c656e67746860408201527f206d69736d617463680000000000000000000000000000000000000000000000606082015260800190565b6020808252601f908201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604082015260600190565b60208082526018908201527f53454e4445525f4e4f545f41535345545f4d414e414745520000000000000000604082015260600190565b60006080825261786460808301876166de565b82810360208401526178768187616605565b604084019590955250506060015292915050565b60006060825261789d60608301866166de565b6001600160801b0394851660208401529290931660409091015292915050565b6001600160801b0391909116815260200190565b6001600160801b0392831681529116602082015260400190565b918252602082015260400190565b60405181810167ffffffffffffffff8111828210171561791857600080fd5b604052919050565b600067ffffffffffffffff821115617936578081fd5b5060209081020190565b60005b8381101561795b578181015183820152602001617943565b83811115612ccd5750506000910152565b60e01c90565b600060443d1015617982576104f0565b600481823e6308c379a0617996825161796c565b146179a0576104f0565b6040517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3d016004823e80513d67ffffffffffffffff81602484011181841117156179ee57505050506104f0565b82840192508251915080821115617a0857505050506104f0565b503d83016020828401011115617a20575050506104f0565b601f01601f1916810160200160405291505090565b6001600160a01b0381168114612b0a57600080fd5b8015158114612b0a57600080fdfea2646970667358221220bcbacfc99ae8e94b2fa18b810b6b6666c9403923ffaf20cdaaafd014e4240bcd64736f6c63430007010033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102265760003560e01c80637576b5f11161012a578063c3946977116100bd578063e6a329091161008c578063f6c0092711610071578063f6c009271461048e578063f90e6570146104af578063f94d4668146104c257610226565b8063e6a3290914610468578063f0f5fd551461047b57610226565b8063c39469771461041c578063c4cd53db1461042f578063d1b33a4814610442578063ddbada601461045557610226565b80638adc5f5d116100f95780638adc5f5d146103e3578063a297857814610404578063aaabadc51461040c578063bb61f6351461041457610226565b80637576b5f1146103a257806375e9cfb7146103b5578063761c52e6146103c85780637a7d3f74146103d057610226565b806323eeca01116101bd5780634b4039f61161018c5780635c38449e116101715780635c38449e1461036957806366a9c7d21461037c57806370c5ae2c1461038f57610226565b80634b4039f6146103435780635233cd6b1461035657610226565b806323eeca01146102ea5780632b8a61631461030a578063379162c41461031d57806338b025051461033057610226565b80630f5a6efa116101f95780630f5a6efa146102915780631adcfe0d146102b15780631faddee5146102c457806321a6eb13146102d757610226565b806307dfca131461022b57806309b2760f146102495780630c0626421461025c5780630e9e98cf1461027c575b600080fd5b6102336104e3565b6040516102409190616a25565b60405180910390f35b6102336102573660046164d8565b6104f3565b61026f61026a3660046162ef565b6105ad565b6040516102409190616796565b61028f61028a366004615e03565b6105ee565b005b6102a461029f366004615e1f565b610708565b604051610240919061691a565b61028f6102bf36600461622e565b6107f3565b61028f6102d236600461617a565b610a10565b6102a46102e53660046163e2565b610cf3565b6102fd6102f8366004616564565b610de9565b6040516102409190616828565b61028f610318366004616162565b610ea2565b6102a461032b366004615ff3565b610fec565b6102a461033e366004615ff3565b61100d565b61028f610351366004616162565b611025565b61028f61036436600461631e565b611170565b61028f610377366004616355565b611283565b61028f61038a366004616278565b6116e7565b61028f61039d36600461631e565b611962565b61028f6103b036600461617a565b611a16565b61028f6103c336600461606c565b611cc7565b610233611d6e565b61028f6103de366004615eee565b611d7f565b6103f66103f13660046162ef565b611f78565b6040516102409291906178eb565b610233612015565b61026f612038565b610233612047565b61028f61042a366004615eee565b61204d565b6102a461043d366004616497565b612247565b61028f61045036600461631e565b6122a0565b61028f610463366004615eee565b6123a2565b61028f610476366004616162565b612523565b61028f610489366004615e6d565b612647565b6104a161049c366004616162565b61281c565b6040516102409291906167e8565b6102336104bd366004615e03565b612846565b6104d56104d0366004616162565b612865565b6040516102409291906168a7565b6003546001600160801b03165b90565b6000600260005414156105215760405162461bcd60e51b8152600401610518906177e3565b60405180910390fd5b6002600090815561053c3384610537600b612a7a565b612a85565b9050600061054b600b83612ad7565b90508061056a5760405162461bcd60e51b81526004016105189061727c565b7f76c4350174727086805a3b026998a38a23dec4eaa173f2eb5449eb961e69c043826040516105999190616a25565b60405180910390a150600160005592915050565b6000826105b981612ae3565b6105c38484612b0d565b50506000918252600d602090815260408084206001600160a01b039384168552909152909120541690565b600260005414156106115760405162461bcd60e51b8152600401610518906177e3565b60026000556001546040517fa962e8690000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063a962e8699061065f903390600401616796565b60206040518083038186803b15801561067757600080fd5b505afa15801561068b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106af9190616146565b6106cb5760405162461bcd60e51b815260040161051890617247565b600180547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0392909216919091178155600055565b606080825167ffffffffffffffff8111801561072357600080fd5b5060405190808252806020026020018201604052801561074d578160200160208202803683370190505b50905060005b83518110156107e9576001600160a01b0385166000908152600560205260408120855190919086908490811061078557fe5b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002060009054906101000a90046001600160801b03166001600160801b03168282815181106107d657fe5b6020908102919091010152600101610753565b5090505b92915050565b600260005414156108165760405162461bcd60e51b8152600401610518906177e3565b60026000558261082581612b37565b600061083085612b75565b9050600281600281111561084057fe5b14156108b857600283146108665760405162461bcd60e51b815260040161051890617145565b6108b3858585600081811061087757fe5b905060200201602081019061088c9190615e03565b8686600181811061089957fe5b90506020020160208101906108ae9190615e03565b612b8b565b610946565b60018160028111156108c657fe5b1415610909576108b385858580806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612c1b92505050565b61094685858580806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612cd392505050565b60005b838110156109c8576000868152600d602052604081209086868481811061096c57fe5b90506020020160208101906109819190615e03565b6001600160a01b03168152602081019190915260400160002080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055600101610949565b507f12f8276099dfd84906c19325f6d9886ec2317c278654dc41b1aefe273a0489368585856040516109fc93929190616a9a565b60405180910390a150506001600055505050565b60026000541415610a335760405162461bcd60e51b8152600401610518906177e3565b600260005585610a4281612ae3565b8351855114610a635760405162461bcd60e51b815260040161051890616cf1565b6060610a6f8887612d4f565b9050606080610a828a89858c8b8a612df6565b915091506060885167ffffffffffffffff81118015610aa057600080fd5b50604051908082528060200260200182016040528015610aca578160200160208202803683370190505b50905060005b8951811015610bee5760008a8281518110610ae757fe5b602002602001015190506000610b0f868481518110610b0257fe5b6020026020010151612eef565b90508a8381518110610b1d57fe5b6020026020010151816001600160801b03161115610b4d5760405162461bcd60e51b815260040161051890617043565b610b598282338d612f25565b6000610b6a868581518110610b0257fe5b6001600160a01b038416600090815260026020526040902054909150610b99906001600160801b038316613010565b6001600160a01b038416600090815260026020526040902055610bc86001600160801b03808416908316613035565b858581518110610bd457fe5b602002602001018181525050505050806001019050610ad0565b506000610bfa8c612b75565b90506002816002811115610c0a57fe5b1415610c7257610c6d8c8b600081518110610c2157fe5b602002602001015184600081518110610c3657fe5b60200260200101518d600181518110610c4b57fe5b602002602001015186600181518110610c6057fe5b602002602001015161307b565b610c9c565b6001816002811115610c8057fe5b1415610c9157610c6d8c8b846130c6565b610c9c8c8b84613130565b336001600160a01b03168c7ff7f95732a0f83c5093bfd147b3c8e57ac41ee39cd0f23cb6e74325e9f8fe1a648686604051610cd8929190616a12565b60405180910390a35050600160005550505050505050505050565b606080610d4c610d02876104f0565b868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250610d4592505050368790038701876164f7565b60006131a7565b90506001600160a01b03891615610ddd576040517f9ab681f20000000000000000000000000000000000000000000000000000000081526001600160a01b038a1690639ab681f290610daa908890889086908e908e9060040161686c565b600060405180830381600087803b158015610dc457600080fd5b505af1158015610dd8573d6000803e3d6000fd5b505050505b98975050505050505050565b6060828210158015610e065750610e00600b612a7a565b83830311155b610e225760405162461bcd60e51b8152600401610518906172b3565b606083830367ffffffffffffffff81118015610e3d57600080fd5b50604051908082528060200260200182016040528015610e67578160200160208202803683370190505b50905060005b81518110156107e957610e83600b8287016133ea565b828281518110610e8f57fe5b6020908102919091010152600101610e6d565b60026000541415610ec55760405162461bcd60e51b8152600401610518906177e3565b6002600055610ed2612038565b6001600160a01b031663026158d5336040518263ffffffff1660e01b8152600401610efd9190616796565b60206040518083038186803b158015610f1557600080fd5b505afa158015610f29573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f4d9190616146565b610f695760405162461bcd60e51b8152600401610518906173c6565b7f00000000000000000000000000000000000000000000000000000000000000006001600160801b0316811115610fb25760405162461bcd60e51b81526004016105189061738f565b610fbb81612eef565b600380546fffffffffffffffffffffffffffffffff19166001600160801b0392909216919091179055506001600055565b6060611004610ffa866104f0565b85858560016133f6565b95945050505050565b606061100461101b866104f0565b85858560006133f6565b600260005414156110485760405162461bcd60e51b8152600401610518906177e3565b6002600055611055612038565b6001600160a01b0316637c3b47f5336040518263ffffffff1660e01b81526004016110809190616796565b60206040518083038186803b15801561109857600080fd5b505afa1580156110ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110d09190616146565b6110ec5760405162461bcd60e51b8152600401610518906171ea565b7f00000000000000000000000000000000000000000000000000000000000000006001600160801b03168111156111355760405162461bcd60e51b8152600401610518906170b1565b61113e81612eef565b600380546001600160801b03928316700100000000000000000000000000000000029216919091179055506001600055565b600260005414156111935760405162461bcd60e51b8152600401610518906177e3565b600260005582826111a482826134ac565b60006111af86612b75565b905060018160028111156111bf57fe5b14156111dd576111d886866111d387612eef565b613502565b611217565b60028160028111156111eb57fe5b1415611204576111d886866111ff87612eef565b613515565b611217868661121287612eef565b613523565b61122b6001600160a01b0386163386613531565b6001600160a01b03851633877fea86d22f498d42c4c5ed8d09366d0af8bb816a7d2265eef1080d0cb6acb517bb611261886135b4565b60405161126e9190616a25565b60405180910390a45050600160005550505050565b600260005414156112a65760405162461bcd60e51b8152600401610518906177e3565b600260005582518451146112cc5760405162461bcd60e51b815260040161051890616ead565b6060845167ffffffffffffffff811180156112e657600080fd5b50604051908082528060200260200182016040528015611310578160200160208202803683370190505b5090506060855167ffffffffffffffff8111801561132d57600080fd5b50604051908082528060200260200182016040528015611357578160200160208202803683370190505b50905060005b86518110156114d35786818151811061137257fe5b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016113a59190616796565b60206040518083038186803b1580156113bd57600080fd5b505afa1580156113d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113f5919061654c565b82828151811061140157fe5b60200260200101818152505085818151811061141957fe5b602002602001015182828151811061142d57fe5b602002602001015110156114535760405162461bcd60e51b8152600401610518906176f2565b61146f86828151811061146257fe5b60200260200101516135f5565b83828151811061147b57fe5b6020026020010181815250506114cb8887838151811061149757fe5b60200260200101518984815181106114ab57fe5b60200260200101516001600160a01b03166135319092919063ffffffff16565b60010161135d565b506040517ff04f27070000000000000000000000000000000000000000000000000000000081526001600160a01b0388169063f04f270790611521908990899087908a908a906004016168cc565b600060405180830381600087803b15801561153b57600080fd5b505af115801561154f573d6000803e3d6000fd5b5050505060005b86518110156116d857600087828151811061156d57fe5b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016115a09190616796565b60206040518083038186803b1580156115b857600080fd5b505afa1580156115cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115f0919061654c565b9050600061161a84848151811061160357fe5b60200260200101518361360c90919063ffffffff16565b905084838151811061162857fe5b602002602001015181101561164f5760405162461bcd60e51b81526004016105189061700c565b61169a81600260008c878151811061166357fe5b60200260200101516001600160a01b03166001600160a01b031681526020019081526020016000205461301090919063ffffffff16565b600260008b86815181106116aa57fe5b6020908102919091018101516001600160a01b03168252810191909152604001600020555050600101611556565b50506001600055505050505050565b6002600054141561170a5760405162461bcd60e51b8152600401610518906177e3565b60026000558461171981612b37565b600061172487612b75565b9050600281600281111561173457fe5b14156117ac576002851461175a5760405162461bcd60e51b815260040161051890617145565b6117a7878787600081811061176b57fe5b90506020020160208101906117809190615e03565b8888600181811061178d57fe5b90506020020160208101906117a29190615e03565b61363d565b61183a565b60018160028111156117ba57fe5b14156117fd576117a7878787808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506137a392505050565b61183a8787878080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061383c92505050565b60005b8581101561191857600085858381811061185357fe5b90506020020160208101906118689190615e03565b9050600088888481811061187857fe5b905060200201602081019061188d9190615e03565b60008b8152600d602090815260408083206001600160a01b038581168086529190935281842080547fffffffffffffffffffffffff00000000000000000000000000000000000000001693881693841790559051939450909290918d917fc438982f36308c6c0153761eaa0cf9f00a59ef4d93338c934468f52bd45296119190a4505060010161183d565b507fb69d13ab78b4f721123e9de02f1779b42ef54bb914fd86024b5a85c4fadfee8887878760405161194c93929190616a9a565b60405180910390a1505060016000555050505050565b600260005414156119855760405162461bcd60e51b8152600401610518906177e3565b6002600055828261199682826134ac565b60006119a186612b75565b905060018160028111156119b157fe5b14156119cf576119ca86866119c587612eef565b6138d6565b611a09565b60028160028111156119dd57fe5b14156119f6576119ca86866119f187612eef565b6138e4565b611a098686611a0487612eef565b6138f2565b5050600160005550505050565b60026000541415611a395760405162461bcd60e51b8152600401610518906177e3565b600260005585611a4881612ae3565b8351855114611a695760405162461bcd60e51b815260040161051890616cf1565b6060611a758887612d4f565b9050606080611a888a89858c8b8a613900565b915091506060885167ffffffffffffffff81118015611aa657600080fd5b50604051908082528060200260200182016040528015611ad0578160200160208202803683370190505b50905060005b8951811015611be75760008a8281518110611aed57fe5b602002602001015190506000611b08868481518110610b0257fe5b90508a8381518110611b1657fe5b6020026020010151816001600160801b03161015611b465760405162461bcd60e51b815260040161051890616dbc565b611b5282828f8d6139cc565b6000611b63868581518110610b0257fe5b6001600160a01b038416600090815260026020526040902054909150611b92906001600160801b038316613010565b6001600160a01b038416600090815260026020526040902055611bc16001600160801b03838116908316613010565b858581518110611bcd57fe5b602002602001018181525050505050806001019050611ad6565b506000611bf38c612b75565b90506002816002811115611c0357fe5b1415611c6157611c5c8c8b600081518110611c1a57fe5b6020026020010151611c3285600081518110610b0257fe5b8d600181518110611c3f57fe5b6020026020010151611c5787600181518110610b0257fe5b613aed565b611c8b565b6001816002811115611c6f57fe5b1415611c8057611c5c8c8b84613afd565b611c8b8c8b84613b46565b336001600160a01b03168c7fe1f0410ab343b6bd5ac108e2e4c8085cef471896ef5214b73d944091850293218686604051610cd8929190616a12565b333014611ce65760405162461bcd60e51b815260040161051890616b5b565b6060611d3586868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250611d2f92505050368790038701876164f7565b85613b9c565b905080604051602001611d48919061691a565b60408051601f198184030181529082905262461bcd60e51b825261051891600401616ab4565b6000611d7a600b612a7a565b905090565b60026000541415611da25760405162461bcd60e51b8152600401610518906177e3565b60026000558151835114611dc85760405162461bcd60e51b815260040161051890617786565b60005b8351811015611f6d576000848281518110611de257fe5b6020908102919091018101513360009081526005835260408082206001600160a01b03841683529093529182205486519193506001600160801b03169190611e3090879086908110610b0257fe5b9050816001600160801b0316816001600160801b03161115611e645760405162461bcd60e51b815260040161051890616b92565b3360009081526005602081815260408084206001600160a01b0388811680875291845282862080546fffffffffffffffffffffffffffffffff1916888a036001600160801b0390811691909117909155908b16865293835281852090855290915290912054611ed4911682613e4d565b6001600160a01b038681166000818152600560209081526040808320948916808452949091529081902080546fffffffffffffffffffffffffffffffff19166001600160801b039590951694909417909355915190919033907fc9427b4a5655c5832a046d33056c59e7191d43a22bd8f93c89277f33efaf45fd90611f5a9086906178bd565b60405180910390a4505050600101611dcb565b505060016000555050565b60008083611f8581612ae3565b600080611f9187612b75565b90506002816002811115611fa157fe5b1415611fb857611fb18787613e7e565b9150611fe3565b6001816002811115611fc657fe5b1415611fd657611fb18787613f6a565b611fe08787613fd4565b91505b611fec82613ff4565b6001600160801b0316945061200082614000565b6001600160801b031693505050509250929050565b60035470010000000000000000000000000000000090046001600160801b031690565b6001546001600160a01b031690565b60045490565b600260005414156120705760405162461bcd60e51b8152600401610518906177e3565b600260005581518351146120965760405162461bcd60e51b815260040161051890617786565b60005b8351811015611f6d5760008482815181106120b057fe5b6020026020010151905060006120cb858481518110610b0257fe5b3360009081526005602090815260408083206001600160a01b03871684529091529020549091506001600160801b0390811690821681101561211f5760405162461bcd60e51b815260040161051890616c5d565b3360009081526005602090815260408083206001600160a01b0387168452909152812080546fffffffffffffffffffffffffffffffff19168484036001600160801b031617905561216f83614006565b6001600160a01b03851660009081526002602052604090205490915061219e906001600160801b038316613010565b6001600160a01b0385166000908152600260205260409020556121e2866121d16001600160801b0386811690851661360c565b6001600160a01b0387169190613531565b836001600160a01b0316866001600160a01b0316336001600160a01b03167f7b875067eda472e508132da5f6930c3a6b21129bcb10c84169bbc72aec9eef7a8660405161222f91906178bd565b60405180910390a45050600190920191506120999050565b606080610d4c612256876104f0565b86868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061229992505050368790038701876164f7565b60016131a7565b600260005414156122c35760405162461bcd60e51b8152600401610518906177e3565b600260005582826122d482826134ac565b6122e96001600160a01b038516333086614022565b60006122f486612b75565b9050600181600281111561230457fe5b14156123225761231d868661231887612eef565b614043565b61235c565b600281600281111561233057fe5b14156123495761231d868661234487612eef565b614051565b61235c868661235787612eef565b61405f565b6001600160a01b03851633877fea86d22f498d42c4c5ed8d09366d0af8bb816a7d2265eef1080d0cb6acb517bb612392886135b4565b60000360405161126e9190616a25565b600260005414156123c55760405162461bcd60e51b8152600401610518906177e3565b600260005581518351146123eb5760405162461bcd60e51b815260040161051890617786565b60005b8351811015611f6d57600084828151811061240557fe5b60200260200101519050600084838151811061241d57fe5b6020026020010151905061246861243382612eef565b6001600160a01b038087166000908152600560209081526040808320938816835292905220546001600160801b031690613e4d565b6001600160a01b03858116600090815260056020908152604080832093871680845293909152902080546fffffffffffffffffffffffffffffffff19166001600160801b0393909316929092179091556124c490333084614022565b816001600160a01b0316846001600160a01b0316336001600160a01b03167fb76281916fe2a7c5a7b2c2d3b84fcc820d3b5546b3d3572a74840423fec96a7c846040516125119190616a25565b60405180910390a450506001016123ee565b600260005414156125465760405162461bcd60e51b8152600401610518906177e3565b6002600055612553612038565b6001600160a01b03166315e61d33336040518263ffffffff1660e01b815260040161257e9190616796565b60206040518083038186803b15801561259657600080fd5b505afa1580156125aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125ce9190616146565b6125ea5760405162461bcd60e51b8152600401610518906170e8565b7f000000000000000000000000000000000000000000000000000000000000000081111561262a5760405162461bcd60e51b815260040161051890616ac7565b61263381612eef565b6001600160801b0316600455506001600055565b6002600054141561266a5760405162461bcd60e51b8152600401610518906177e3565b600260005583821461268e5760405162461bcd60e51b815260040161051890616ead565b6000612698612038565b905060005b8581101561280e5760008787838181106126b357fe5b90506020020160208101906126c89190615e03565b6040517f75f101590000000000000000000000000000000000000000000000000000000081529091506001600160a01b038416906375f101599061271290339085906004016167aa565b60206040518083038186803b15801561272a57600080fd5b505afa15801561273e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127629190616146565b61277e5760405162461bcd60e51b815260040161051890616c00565b600086868481811061278c57fe5b9050602002013590508060026000846001600160a01b03166001600160a01b031681526020019081526020016000205410156127da5760405162461bcd60e51b81526004016105189061700c565b6001600160a01b038216600081815260026020526040902080548390039055612804908683613531565b505060010161269d565b505060016000555050505050565b6000808261282981612ae3565b6128328461406d565b61283b85612b75565b925092505b50915091565b6001600160a01b0381166000908152600260205260409020545b919050565b6060808261287281612ae3565b600061287d85612b75565b9050600281600281111561288d57fe5b14156128a65761289c85614073565b9350935050612840565b60018160028111156128b457fe5b14156128c35761289c85614236565b61289c85614366565b5050915091565b60008282026001600160801b038416158061291a5750826001600160801b0316846001600160801b0316826001600160801b03168161290e57fe5b046001600160801b0316145b6129365760405162461bcd60e51b815260040161051890617358565b6706f05b59d3b2000081016001600160801b03808316908216101561296d5760405162461bcd60e51b815260040161051890617358565b6000670de0b6b3a76400006001600160801b0383165b049695505050505050565b60006001600160801b0382166129b65760405162461bcd60e51b815260040161051890617423565b670de0b6b3a764000083026001600160801b03841615806129fc5750670de0b6b3a76400006001600160801b03858116908316816129f057fe5b046001600160801b0316145b612a185760405162461bcd60e51b81526004016105189061717c565b600060026001600160801b0385160482019050816001600160801b0316816001600160801b03161015612a5d5760405162461bcd60e51b81526004016105189061717c565b6000846001600160801b0316826001600160801b03168161298357fe5b60006107ed82614487565b600069ffffffffffffffffffff82166050846002811115612aa257fe5b901b17606085901b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000161790505b9392505050565b6000612ad0838361448b565b612aee600b826144d5565b612b0a5760405162461bcd60e51b815260040161051890616cba565b50565b612b1782826144e1565b612b335760405162461bcd60e51b815260040161051890617321565b5050565b612b4081612ae3565b6000612b4b8261406d565b90506001600160a01b0381163314612b335760405162461bcd60e51b81526004016105189061707a565b600061ffff605083901c1660028111156107ed57fe5b600080612b9985858561453d565b5091509150612ba7826145f5565b8015612bb75750612bb7816145f5565b612bd35760405162461bcd60e51b815260040161051890616d85565b50505060009182525060096020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000009081168255600190910180549091169055565b6000828152600760205260408120905b8251811015612ccd576000838281518110612c4257fe5b60209081029190910181015160008781526008835260408082206001600160a01b03841683529093529190912054909150612c7c906145f5565b612c985760405162461bcd60e51b815260040161051890616d85565b6000612ca484836145f9565b905080612cc35760405162461bcd60e51b815260040161051890617321565b5050600101612c2b565b50505050565b6000828152600660205260408120905b8251811015612ccd576000838281518110612cfa57fe5b602002602001015190506000612d10848361460e565b9050612d1b816145f5565b612d375760405162461bcd60e51b815260040161051890616d85565b612d41848361465a565b505050806001019050612ce3565b6060806060612d5d85612865565b915091508351825114612d825760405162461bcd60e51b8152600401610518906174c8565b60005b8251811015612ded57848181518110612d9a57fe5b60200260200101516001600160a01b0316838281518110612db757fe5b60200260200101516001600160a01b031614612de55760405162461bcd60e51b8152600401610518906174c8565b600101612d85565b50949350505050565b6060806000612e048961406d565b9050806001600160a01b0316630385ccea8a33898b8a612e22612015565b8b6040518863ffffffff1660e01b8152600401612e459796959493929190616a2e565b600060405180830381600087803b158015612e5f57600080fd5b505af1158015612e73573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612e9b91908101906160ef565b8951825192955090935014612ec25760405162461bcd60e51b815260040161051890616d4e565b8751825114612ee35760405162461bcd60e51b815260040161051890617638565b50965096945050505050565b60007001000000000000000000000000000000008210612f215760405162461bcd60e51b815260040161051890616df3565b5090565b6001600160801b038316612f3857612ccd565b828115612fdc576001600160a01b0380841660009081526005602090815260408083209389168352929052908120546001600160801b039081169190612f8a90612f85908490861661466f565b612eef565b6001600160a01b038681166000908152600560209081526040808320938c1683529290522080546fffffffffffffffffffffffffffffffff1916938290036001600160801b0316939093179092555090035b6001600160801b03811615613009576130096001600160a01b03861684306001600160801b038516614022565b5050505050565b600082820183811015612ad05760405162461bcd60e51b815260040161051890617601565b600081830381831280159061304a5750838113155b8061305f575060008312801561305f57508381135b612ad05760405162461bcd60e51b815260040161051890617695565b613009858561308c612f8587614685565b6000871361309c576146a16130a0565b6146d95b866130ad612f8588614685565b600088136130bd576146a16130c1565b6146d95b6146f8565b60005b8251811015612ccd5760008282815181106130e057fe5b60200260200101519050613127858584815181106130fa57fe5b602002602001015160008413613112576146a1613116565b6146d95b613122612f8586614685565b614785565b506001016130c9565b6000838152600660205260408120905b835181101561300957600083828151811061315757fe5b6020026020010151905061319e8386848151811061317157fe5b602002602001015160008413613189576146a161318d565b6146d95b613199612f8586614685565b6147cf565b50600101613140565b6060600260005414156131cc5760405162461bcd60e51b8152600401610518906177e3565b600260005560606131df86868686613b9c565b905060005b85518110156133db5760008682815181106131fb57fe5b60200260200101519050600083838151811061321357fe5b602002602001015113156132f557600083838151811061322f57fe5b602002602001015190508660200151156132d1573360009081526005602090815260408083206001600160a01b03861684529091528120546001600160801b039081169190613281908390851661466f565b3360009081526005602090815260408083206001600160a01b0389168452909152902080546fffffffffffffffffffffffffffffffff1916938290036001600160801b0316939093179092555090035b6132ef6001600160a01b03831633306001600160801b038516614022565b506133d2565b6000613316612f8585858151811061330957fe5b6020026020010151614685565b90508660400151156133b05786516001600160a01b0390811660009081526005602090815260408083209386168352929052205461335d906001600160801b031682613e4d565b87516001600160a01b03908116600090815260056020908152604080832093871683529290522080546fffffffffffffffffffffffffffffffff19166001600160801b03929092169190911790556133d0565b86516133d0906001600160a01b038416906001600160801b038416613531565b505b506001016131e4565b50600160005595945050505050565b6000612ad083836147ff565b6040517f75e9cfb700000000000000000000000000000000000000000000000000000000815260609030906375e9cfb79061343d908990899089908990899060040161692d565b600060405180830381600087803b15801561345757600080fd5b505af1925050508015613468575060015b6134aa57613474617972565b8061347f575061349b565b808060200190518101906134939190615f63565b9150506134a5565b3d6000803e3d6000fd5b611004565bfe5b6134b582612ae3565b6134bf8282612b0d565b6000828152600d602090815260408083206001600160a01b038581168552925290912054163314612b335760405162461bcd60e51b81526004016105189061781a565b613510838361484484614785565b505050565b613510838361484484614865565b61351083836148448461497f565b6135108363a9059cbb60e01b848460405160240161355092919061680f565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152614999565b60007f80000000000000000000000000000000000000000000000000000000000000008210612f215760405162461bcd60e51b81526004016105189061756d565b60006107ed60045483614a2890919063ffffffff16565b600080600061361b8585614a9a565b9150915080156107e95760405162461bcd60e51b8152600401610518906175ca565b6001600160a01b0382161580159061365d57506001600160a01b03811615155b6136795760405162461bcd60e51b81526004016105189061745a565b806001600160a01b0316826001600160a01b031614156136ab5760405162461bcd60e51b8152600401610518906171b3565b6136b3615a91565b50600083815260096020908152604091829020825180840190935280546001600160a01b039081168085526001909201541691830191909152158015613704575060208101516001600160a01b0316155b6137205760405162461bcd60e51b815260040161051890616f9e565b60008061372d8585614abf565b6040805180820182526001600160a01b039384168152918316602080840191825260009a8b52600990529820905181547fffffffffffffffffffffffff00000000000000000000000000000000000000009081169184169190911782559751600190910180549098169116179095555050505050565b6000828152600760205260408120905b8251811015612ccd5760008382815181106137ca57fe5b6020026020010151905060006001600160a01b0316816001600160a01b031614156138075760405162461bcd60e51b81526004016105189061745a565b60006138138483614af0565b9050806138325760405162461bcd60e51b8152600401610518906171b3565b50506001016137b3565b6000828152600660205260408120905b8251811015612ccd57600083828151811061386357fe5b6020026020010151905060006001600160a01b0316816001600160a01b031614156138a05760405162461bcd60e51b81526004016105189061745a565b60006138ad848383614b05565b9050806138cc5760405162461bcd60e51b8152600401610518906171b3565b505060010161384c565b6135108383614b1b84614785565b6135108383614b1b84614865565b6135108383614b1b8461497f565b606080600061390e8961406d565b9050806001600160a01b03166345c6472c8a33898b8a61392c612015565b8b6040518863ffffffff1660e01b815260040161394f9796959493929190616a2e565b600060405180830381600087803b15801561396957600080fd5b505af115801561397d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526139a591908101906160ef565b8951825192955090935014612ec25760405162461bcd60e51b815260040161051890616bc9565b6001600160801b0383166139df57612ccd565b8015613a6f576001600160a01b03808316600090815260056020908152604080832093881683529290522054613a1e906001600160801b031684613e4d565b6001600160a01b03838116600090815260056020908152604080832093891683529290522080546fffffffffffffffffffffffffffffffff19166001600160801b0392909216919091179055612ccd565b6000613a7a84614006565b6001600160a01b038616600090815260026020526040902054909150613aa9906001600160801b038316613010565b6001600160a01b03861660009081526002602052604090205561300983613adc6001600160801b0387811690851661360c565b6001600160a01b0388169190613531565b61300985858585856146a1614b33565b60005b8251811015612ccd576000613b1a838381518110610b0257fe5b9050613b3d85858481518110613b2c57fe5b60200260200101516146a184614785565b50600101613b00565b6000838152600660205260408120905b8351811015613009576000613b70848381518110610b0257fe5b9050613b9383868481518110613b8257fe5b60200260200101516146a1846147cf565b50600101613b56565b6060835167ffffffffffffffff81118015613bb657600080fd5b50604051908082528060200260200182016040528015613be0578160200160208202803683370190505b509050613beb615a91565b613bf3615aa8565b60005b8751811015613e4257878181518110613c0b57fe5b6020026020010151915086518260200151108015613c2d575086518260400151105b613c495760405162461bcd60e51b815260040161051890616f0a565b600087836020015181518110613c5b57fe5b60200260200101519050600088846040015181518110613c7757fe5b60200260200101519050806001600160a01b0316826001600160a01b03161415613cb35760405162461bcd60e51b8152600401610518906172ea565b6060840151613d3b5760018a511115613d23576000613cd3888484614bbf565b6001600160a01b031686600001516001600160a01b031614905080613d0a5760405162461bcd60e51b815260040161051890617491565b5060208501516001600160801b03166060850152613d3b565b60405162461bcd60e51b815260040161051890616fd5565b600080613d51848488338e600001518c8f614be1565b91509150613d7f88876020015181518110613d6857fe5b6020026020010151836001600160801b0316614cb8565b88876020015181518110613d8f57fe5b602002602001018181525050613dc588876040015181518110613dae57fe5b6020026020010151826001600160801b0316613035565b88876040015181518110613dd557fe5b602002602001018181525050826001600160a01b0316846001600160a01b031687600001517f2170c741c41531aec20e7c107c24eecfdd15e69c9bb0a8dd37b1840b9e0b207b8585604051613e2b9291906178d1565b60405180910390a450505050806001019050613bf6565b505050949350505050565b60008282016001600160801b038085169082161015612ad05760405162461bcd60e51b815260040161051890617601565b6000613e88615a91565b506000838152600960209081526040808320815180830190925280546001600160a01b0390811680845260019092015416928201839052909291613ecc9190614cfe565b6000868152600a60209081526040808320848452909152902080546001820154855193945091929091906001600160a01b0388811691161415613f1f57613f138282614d31565b955050505050506107ed565b84602001516001600160a01b0316876001600160a01b03161415613f4757613f138282614d4d565b60405162461bcd60e51b815260040161051890617321565b505050505092915050565b60008281526008602090815260408083206001600160a01b038516845290915281205481613f9782614d64565b80613fb557506000858152600760205260409020613fb59085614d76565b9050806107e95760405162461bcd60e51b815260040161051890617321565b6000828152600660205260408120613fec818461460e565b949350505050565b6001600160801b031690565b60801c90565b6003546000906107ed906001600160801b0384811691166128d3565b612ccd846323b872dd60e01b858585604051602401613550939291906167c4565b6135108383614d8b84614785565b6135108383614d8b84614865565b6135108383614d8b8461497f565b60601c90565b60608061407e615a91565b50600083815260096020908152604091829020825180840190935280546001600160a01b03908116808552600190920154169183019190915215806140ce575060208101516001600160a01b0316155b156140f2575050604080516000808252602082019081528183019092529150614231565b604080516002808252606082018352909160208301908036833701905050925080600001518360008151811061412457fe5b60200260200101906001600160a01b031690816001600160a01b03168152505080602001518360018151811061415657fe5b6001600160a01b039290921660209283029190910182015260408051600280825260608201835290929091908301908036833701905050915060006141a382600001518360200151614cfe565b6000868152600a6020908152604080832084845290915290208054600182015492935090916141da6141d58383614d31565b614dac565b6001600160801b0316866000815181106141f057fe5b6020026020010181815250506142096141d58383614d4d565b6001600160801b03168660018151811061421f57fe5b60200260200101818152505050505050505b915091565b6000818152600760205260409020606090819061425281612a7a565b67ffffffffffffffff8111801561426857600080fd5b50604051908082528060200260200182016040528015614292578160200160208202803683370190505b509250825167ffffffffffffffff811180156142ad57600080fd5b506040519080825280602002602001820160405280156142d7578160200160208202803683370190505b50915060005b83518110156128cc5760006142f283836133ea565b90508085838151811061430157fe5b6001600160a01b039283166020918202929092018101919091526000888152600882526040808220938516825292909152205461433d90614dac565b6001600160801b031684838151811061435257fe5b6020908102919091010152506001016142dd565b6000818152600660205260409020606090819061438281612a7a565b67ffffffffffffffff8111801561439857600080fd5b506040519080825280602002602001820160405280156143c2578160200160208202803683370190505b509250825167ffffffffffffffff811180156143dd57600080fd5b50604051908082528060200260200182016040528015614407578160200160208202803683370190505b50915060005b83518110156128cc576000806144238484614dc3565b915091508186848151811061443457fe5b60200260200101906001600160a01b031690816001600160a01b03168152505061445d81614dac565b6001600160801b031685848151811061447257fe5b6020908102919091010152505060010161440d565b5490565b60006144978383614ddf565b6144cd575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556107ed565b5060006107ed565b6000612ad08383614ddf565b6000806144ed84612b75565b905060028160028111156144fd57fe5b14156145155761450d8484614df7565b9150506107ed565b600181600281111561452357fe5b14156145335761450d8484614e78565b61450d8484614e90565b600080600080600061454f8787614abf565b91509150600061455f8383614cfe565b60008a8152600a602090815260408083208484529091528120805460018201549197509293509061458f83614d64565b8061459e575061459e82614d64565b806145af57506145af8c8787614ea8565b9050806145ce5760405162461bcd60e51b815260040161051890617321565b6145d88383614d31565b98506145e48383614d4d565b975050505050505093509350939050565b1590565b6000612ad0836001600160a01b038416614f19565b6000612ad0826040518060400160405280601881526020017f4552525f544f4b454e5f4e4f545f52454749535445524544000000000000000081525085614ffd9092919063ffffffff16565b6000612ad0836001600160a01b038416615013565b600081831061467e5781612ad0565b5090919050565b600080821315614696575080612860565b816000039050612860565b6000806146c0836146b186613ff4565b6001600160801b0316906150aa565b905060006146cd85614000565b905061100482826150b9565b6000806146c0836146e986613ff4565b6001600160801b031690613e4d565b60008060006147088a8a8861453d565b925092509250856001600160a01b0316896001600160a01b0316101561474d5761473683898963ffffffff16565b925061474682868663ffffffff16565b915061476e565b61475b83868663ffffffff16565b925061476b82898963ffffffff16565b91505b6147788383615115565b9055505050505050505050565b60006147918585613f6a565b90506147a181838563ffffffff16565b60009586526008602090815260408088206001600160a01b0390971688529590529390942092909255505050565b60006147db858561460e565b90506147f7846147ef83858763ffffffff16565b879190614b05565b505050505050565b815460009082106148225760405162461bcd60e51b815260040161051890616afe565b82600001828154811061483157fe5b9060005260206000200154905092915050565b600080614854836146b186613ff4565b905060006146cd846146e987614000565b61486d615a91565b506000848152600960209081526040808320815180830190925280546001600160a01b03908116808452600190920154169282018390529092916148b19190614cfe565b6000878152600a60209081526040808320848452909152812080546001820154939450909290916148e28383614d31565b905060006148f08484614d4d565b905086600001516001600160a01b03168a6001600160a01b031614156149255761491e82898b63ffffffff16565b9150614954565b86602001516001600160a01b03168a6001600160a01b03161415613f475761495181898b63ffffffff16565b90505b61495e8282615115565b855561496a8282615147565b85600101819055505050505050505050505050565b6000848152600660205260409020613009818585856147cf565b60606149ee826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166151669092919063ffffffff16565b8051909150156135105780806020019051810190614a0c9190616146565b6135105760405162461bcd60e51b815260040161051890617729565b6000828202831580614a42575082848281614a3f57fe5b04145b614a5e5760405162461bcd60e51b815260040161051890617358565b6706f05b59d3b20000810181811015614a895760405162461bcd60e51b815260040161051890617358565b6000670de0b6b3a764000082612983565b600080828410614ab05750508082036000614ab8565b505081810360015b9250929050565b600080826001600160a01b0316846001600160a01b031610614ae2578284614ae5565b83835b915091509250929050565b6000612ad0836001600160a01b03841661448b565b6000613fec846001600160a01b03851684615175565b600080614b2784613ff4565b9050613fec81846150b9565b6000806000614b4389898861453d565b925092509250856001600160a01b0316886001600160a01b03161015614b8857614b7183888663ffffffff16565b9250614b8182868663ffffffff16565b9150614ba9565b614b9683868663ffffffff16565b9250614ba682888663ffffffff16565b91505b614bb38383615115565b90555050505050505050565b600080846001811115614bce57fe5b14614bd95781613fec565b509092915050565b6000806000614bf38860600151612eef565b9050614bfd615ada565b6040518060e001604052808c6001600160a01b031681526020018b6001600160a01b03168152602001836001600160801b031681526020018a600001518152602001896001600160a01b03168152602001886001600160a01b031681526020018a6080015181525090506000614c738287615216565b9050614c80868d8d615291565b6001600160a01b031687526001600160801b0381166020880152614ca58684836152b2565b909d909c509a5050505050505050505050565b6000828201818312801590614ccd5750838112155b80614ce25750600083128015614ce257508381125b612ad05760405162461bcd60e51b815260040161051890616e50565b60008282604051602001614d1392919061675c565b60405160208183030381529060405280519060200120905092915050565b6000612ad0614d3f84614000565b614d4884614000565b6150b9565b6000612ad0614d5b84613ff4565b614d4884613ff4565b6000614d6f826145f5565b1592915050565b6000612ad0836001600160a01b038416614ddf565b600080614d9b836146e986613ff4565b905060006146cd846146b187614000565b60006107ed614dba83614000565b6146e984613ff4565b6000808080614dd286866152e0565b9097909650945050505050565b60009081526001919091016020526040902054151590565b6000614e01615a91565b50600083815260096020908152604091829020825180840190935280546001600160a01b039081168085526001909201548116928401929092529084161480614e5f575080602001516001600160a01b0316836001600160a01b0316145b8015613fec575050506001600160a01b03161515919050565b6000828152600760205260408120613fec8184614d76565b6000828152600660205260408120613fec81846152fa565b6000614eb2615a91565b50600084815260096020908152604091829020825180840190935280546001600160a01b03908116808552600190920154811692840192909252908516148015611004575080602001516001600160a01b0316836001600160a01b03161495945050505050565b60008181526001830160205260408120548015614ff35783547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8083019190810190600090879083908110614f6a57fe5b9060005260206000200154905080876000018481548110614f8757fe5b600091825260208083209091019290925582815260018981019092526040902090840190558654879080614fb757fe5b600190038181906000526020600020016000905590558660010160008781526020019081526020016000206000905560019450505050506107ed565b60009150506107ed565b6000613fec846001600160a01b0385168461530f565b60008181526002830160205260408120548015614ff35783547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90810160008181526001808801602090815260408084209587018452808420865481558684018054918501919091558654855260028b019092528084209690965593829055928190559086558481529182209190915590506107ed565b600080600061361b8585615329565b60008282016001600160801b0380851690821610156150ea5760405162461bcd60e51b8152600401610518906174ff565b50506fffffffffffffffffffffffffffffffff19608082901b166001600160801b0383161792915050565b600061512082613ff4565b6001600160801b0316608061513485613ff4565b6001600160801b0316901b019392505050565b600061515282614000565b6001600160801b0316608061513485614000565b6060613fec8484600085615351565b6000828152600284016020526040812054806151d85750508254604080518082018252848152602080820185815260008581526001808a018452858220945185559151938201939093559384018088558683526002880190915291902055612ad0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016000908152600180860160205260408220018390559050612ad0565b600080615226846060015161406d565b905060006152378560600151612b75565b9050600181600281111561524757fe5b141561525f57615258858386615412565b9250615289565b600281600281111561526d57fe5b141561527e576152588583866155c9565b611004858386615728565b505092915050565b6000808460018111156152a057fe5b146152ab5782613fec565b5092915050565b600080808560018111156152c257fe5b14156152d25750829050816152d8565b50819050825b935093915050565b600090815260019182016020526040902080549101549091565b6000612ad0836001600160a01b038416615984565b60008061531d85858561599c565b905061100485826159f7565b600080826001600160801b0316846001600160801b031610614ab05750508082036000614ab8565b6060824710156153735760405162461bcd60e51b815260040161051890616f41565b61537c85615a0d565b6153985760405162461bcd60e51b815260040161051890617536565b60006060866001600160a01b031685876040516153b59190616740565b60006040518083038185875af1925050503d80600081146153f2576040519150601f19603f3d011682016040523d82523d6000602084013e6153f7565b606091505b5091509150615407828286615a13565b979650505050505050565b60008061542785606001518660000151613f6a565b9050600061543d86606001518760200151613f6a565b9050600061544a83614dac565b9050600061545783614dac565b9050600086600181111561546757fe5b141561552b5760006154fc886001600160a01b0316633d28000161548a8c615a4c565b86866040518463ffffffff1660e01b81526004016154aa9392919061788a565b602060405180830381600087803b1580156154c457600080fd5b505af11580156154d8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f85919061654c565b905061551561550e8a60400151612eef565b86906146d9565b945061552184826146a1565b9095509250615573565b6000615548886001600160a01b03166395dc27ee61548a8c615a4c565b905061555485826146d9565b945061556d6155668a60400151612eef565b85906146a1565b90955092505b505060608601805160009081526008602081815260408084208b516001600160a01b0390811686529083528185209790975593518352908152828220988101519094168152969092529420939093555090919050565b6000806000806155e687606001518860000151896020015161453d565b92509250925060008088602001516001600160a01b031689600001516001600160a01b0316101561561b575083905082615621565b50829050835b600061562c83614dac565b9050600061563983614dac565b9050600089600181111561564957fe5b141561569457600061566c8b6001600160a01b0316633d28000161548a8f615a4c565b905061567e61550e8d60400151612eef565b945061568a84826146a1565b90985092506156d5565b60006156b18b6001600160a01b03166395dc27ee61548a8f615a4c565b90506156bd85826146d9565b94506156cf6155668d60400151612eef565b90985092505b60008b602001516001600160a01b03168c600001516001600160a01b0316101561570a576157038585615115565b9050615717565b6157148486615115565b90505b909455509498975050505050505050565b6060830151600090815260066020908152604080832086518251808401909352601883527f4552525f544f4b454e5f4e4f545f5245474953544552454400000000000000009383019390935283928392839161578691849190615a54565b905060006157d889602001516040518060400160405280601881526020017f4552525f544f4b454e5f4e4f545f52454749535445524544000000000000000081525085615a549092919063ffffffff16565b905060606157e584612a7a565b67ffffffffffffffff811180156157fb57600080fd5b50604051908082528060200260200182016040528015615825578160200160208202803683370190505b50805190915060005b818110156158935760006158428783615a6a565b905061584d81614dac565b6001600160801b031684838151811061586257fe5b6020026020010181815250508582141561587e5780985061588a565b8482141561588a578097505b5060010161582e565b5060008960018111156158a257fe5b14156159175760006158e78b6001600160a01b03166363df3b436158c58f615a4c565b8689896040518563ffffffff1660e01b81526004016154aa9493929190617851565b90508098506159036158fc8d60400151612eef565b89906146d9565b975061590f87826146a1565b965050615960565b60006159348b6001600160a01b031663a9a3f0376158c58f615a4c565b985088905061594388826146d9565b975061595c6159558d60400151612eef565b88906146a1565b9650505b61596b858589615a76565b615976858488615a76565b505050505050509392505050565b60009081526002919091016020526040902054151590565b600082815260028401602052604081205482816159cc5760405162461bcd60e51b81526004016105189190616ab4565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01949350505050565b6000908152600191820160205260409020015490565b3b151590565b60608315615a22575081612ad0565b825115615a325782518084602001fd5b8160405162461bcd60e51b81526004016105189190616ab4565b612f21615ada565b6000613fec846001600160a01b0385168461599c565b6000612ad083836159f7565b60008281526001808501602052604090912001819055613510565b604080518082019091526000808252602082015290565b6040518060a0016040528060008019168152602001600081526020016000815260200160008152602001606081525090565b6040805160e08101825260008082526020820181905291810182905260608082018390526080820183905260a082019290925260c081019190915290565b60008083601f840112615b29578182fd5b50813567ffffffffffffffff811115615b40578182fd5b6020830191508360208083028501011115614ab857600080fd5b600082601f830112615b6a578081fd5b8135615b7d615b7882617920565b6178f9565b818152915060208083019084810181840286018201871015615b9e57600080fd5b60005b84811015613f5f578135615bb481617a35565b84529282019290820190600101615ba1565b600082601f830112615bd6578081fd5b8135615be4615b7882617920565b818152915060208083019084810160005b84811015613f5f578135870160a080601f19838c03011215615c1657600080fd5b615c1f816178f9565b85830135815260408084013587830152606080850135828401526080915081850135818401525082840135925067ffffffffffffffff831115615c6157600080fd5b615c6f8c8885870101615d83565b90820152865250509282019290820190600101615bf5565b600082601f830112615c97578081fd5b8135615ca5615b7882617920565b818152915060208083019084810181840286018201871015615cc657600080fd5b60005b84811015613f5f57813584529282019290820190600101615cc9565b600082601f830112615cf5578081fd5b8151615d03615b7882617920565b818152915060208083019084810181840286018201871015615d2457600080fd5b60005b84811015613f5f57815184529282019290820190600101615d27565b60008083601f840112615d54578182fd5b50813567ffffffffffffffff811115615d6b578182fd5b602083019150836020828501011115614ab857600080fd5b600082601f830112615d93578081fd5b813567ffffffffffffffff811115615da9578182fd5b615dbc6020601f19601f840116016178f9565b9150808252836020828501011115615dd357600080fd5b8060208401602084013760009082016020015292915050565b600060608284031215615dfd578081fd5b50919050565b600060208284031215615e14578081fd5b8135612ad081617a35565b60008060408385031215615e31578081fd5b8235615e3c81617a35565b9150602083013567ffffffffffffffff811115615e57578182fd5b615e6385828601615b5a565b9150509250929050565b600080600080600060608688031215615e84578081fd5b853567ffffffffffffffff80821115615e9b578283fd5b615ea789838a01615b18565b90975095506020880135915080821115615ebf578283fd5b50615ecc88828901615b18565b9094509250506040860135615ee081617a35565b809150509295509295909350565b600080600060608486031215615f02578081fd5b833567ffffffffffffffff80821115615f19578283fd5b615f2587838801615b5a565b94506020860135915080821115615f3a578283fd5b50615f4786828701615c87565b9250506040840135615f5881617a35565b809150509250925092565b60006020808385031215615f75578182fd5b825167ffffffffffffffff811115615f8b578283fd5b8301601f81018513615f9b578283fd5b8051615fa9615b7882617920565b8181528381019083850185840285018601891015615fc5578687fd5b8694505b83851015615fe7578051835260019490940193918501918501615fc9565b50979650505050505050565b60008060008060a08587031215616008578182fd5b843567ffffffffffffffff8082111561601f578384fd5b61602b88838901615bc6565b95506020870135915080821115616040578384fd5b5061604d87828801615b18565b909450925061606190508660408701615dec565b905092959194509250565b600080600080600060c08688031215616083578283fd5b853567ffffffffffffffff8082111561609a578485fd5b6160a689838a01615bc6565b965060208801359150808211156160bb578485fd5b506160c888828901615b18565b90955093506160dc90508760408801615dec565b915060a086013560028110615ee0578182fd5b60008060408385031215616101578182fd5b825167ffffffffffffffff80821115616118578384fd5b61612486838701615ce5565b93506020850151915080821115616139578283fd5b50615e6385828601615ce5565b600060208284031215616157578081fd5b8151612ad081617a4a565b600060208284031215616173578081fd5b5035919050565b60008060008060008060c08789031215616192578384fd5b8635955060208701356161a481617a35565b9450604087013567ffffffffffffffff808211156161c0578586fd5b6161cc8a838b01615b5a565b955060608901359150808211156161e1578283fd5b6161ed8a838b01615c87565b9450608089013591506161ff82617a4a565b90925060a08801359080821115616214578283fd5b5061622189828a01615d83565b9150509295509295509295565b600080600060408486031215616242578081fd5b83359250602084013567ffffffffffffffff81111561625f578182fd5b61626b86828701615b18565b9497909650939450505050565b60008060008060006060868803121561628f578283fd5b85359450602086013567ffffffffffffffff808211156162ad578485fd5b6162b989838a01615b18565b909650945060408801359150808211156162d1578283fd5b506162de88828901615b18565b969995985093965092949392505050565b60008060408385031215616301578182fd5b82359150602083013561631381617a35565b809150509250929050565b600080600060608486031215616332578081fd5b83359250602084013561634481617a35565b929592945050506040919091013590565b60008060008060006080868803121561636c578283fd5b853561637781617a35565b9450602086013567ffffffffffffffff80821115616393578485fd5b61639f89838a01615b5a565b955060408801359150808211156163b4578485fd5b6163c089838a01615c87565b945060608801359150808211156163d5578283fd5b506162de88828901615d43565b600080600080600080600060e0888a0312156163fc578485fd5b873561640781617a35565b9650602088013567ffffffffffffffff80821115616423578687fd5b61642f8b838c01615d43565b909850965060408a0135915080821115616447578283fd5b6164538b838c01615bc6565b955060608a0135915080821115616468578283fd5b506164758a828b01615b18565b909450925061648990508960808a01615dec565b905092959891949750929550565b600080600080600080600060e0888a0312156164b1578081fd5b87356164bc81617a35565b9650602088013567ffffffffffffffff80821115616423578283fd5b6000602082840312156164e9578081fd5b813560038110612ad0578182fd5b600060608284031215616508578081fd5b61651260606178f9565b823561651d81617a35565b8152602083013561652d81617a4a565b6020820152604083013561654081617a4a565b60408201529392505050565b60006020828403121561655d578081fd5b5051919050565b60008060408385031215616576578182fd5b50508035926020909101359150565b60008284526020808501945082825b858110156165c25781356165a781617a35565b6001600160a01b031687529582019590820190600101616594565b509495945050505050565b6000815180845260208085019450808401835b838110156165c25781516001600160a01b0316875295820195908201906001016165e0565b6000815180845260208085019450808401835b838110156165c257815187529582019590820190600101616618565b60008284528282602086013780602084860101526020601f19601f85011685010190509392505050565b60008151808452616676816020860160208601617940565b601f01601f19169290920160200192915050565b6002811061669457fe5b9052565b80356166a381617a35565b6001600160a01b0316825260208101356166bc81617a4a565b1515602083015260408101356166d181617a4a565b8015156040840152505050565b60006001600160a01b0380835116845280602084015116602085015260408301516040850152606083015160608501528060808401511660808501528060a08401511660a08501525060c082015160e060c0850152613fec60e085018261665e565b60008251616752818460208701617940565b9190910192915050565b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606093841b811682529190921b16601482015260280190565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6001600160a01b0383168152604081016003831061680257fe5b8260208301529392505050565b6001600160a01b03929092168252602082015260400190565b6020808252825182820181905260009190848201906040850190845b8181101561686057835183529284019291840191600101616844565b50909695505050505050565b600060608252616880606083018789616585565b82810360208401526168928187616605565b90508281036040840152610ddd818587616634565b6000604082526168ba60408301856165cd565b82810360208401526110048185616605565b6000608082526168df60808301886165cd565b82810360208401526168f18188616605565b905082810360408401526169058187616605565b90508281036060840152610ddd818587616634565b600060208252612ad06020830184616605565b600060c0820160c0835280885180835260e0850191506020925060e0838202860101838b01855b838110156169d4578783037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff200185528151805184528681015187850152604080820151908501526060808201519085015260809081015160a0918501829052906169c08186018361665e565b968801969450505090850190600101616954565b5050858103848701526169e8818a8c616585565b9450505050506169fb6040830185616698565b616a0860a083018461668a565b9695505050505050565b6000604082526168ba6040830185616605565b90815260200190565b60008882526001600160a01b03808916602084015280881660408401525060e06060830152616a6060e0830187616605565b8281036080840152616a728187616605565b90508460a084015282810360c0840152616a8c818561665e565b9a9950505050505050505050565b600084825260406020830152611004604083018486616585565b600060208252612ad0602083018461665e565b60208082526016908201527f466c6173684c6f616e2066656520746f6f206869676800000000000000000000604082015260600190565b60208082526022908201527f456e756d657261626c655365743a20696e646578206f7574206f6620626f756e60408201527f6473000000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526017908201527f43616c6c6572206973206e6f7420746865205661756c74000000000000000000604082015260600190565b6020808252601f908201527f4552525f4e4f545f454e4f5547485f494e5445524e414c5f42414c414e434500604082015260600190565b60208082526016908201527f4552525f414d4f554e54535f4f55545f4c454e47544800000000000000000000604082015260600190565b60208082526024908201527f43616c6c65722063616e6e6f742077697468647261772070726f746f636f6c2060408201527f6665657300000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526026908201527f5661756c743a20776974686472617720616d6f756e742065786365656473206260408201527f616c616e63650000000000000000000000000000000000000000000000000000606082015260800190565b60208082526010908201527f4e6f6e6578697374656e7420706f6f6c00000000000000000000000000000000604082015260600190565b60208082526022908201527f4552525f544f4b454e535f414d4f554e54535f4c454e4754485f4d49534d415460408201527f4348000000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526015908201527f4552525f414d4f554e54535f494e5f4c454e4754480000000000000000000000604082015260600190565b6020808252601d908201527f4552525f544f4b454e5f42414c414e43455f49535f4e4f545f5a45524f000000604082015260600190565b60208082526012908201527f4552525f455849545f42454c4f575f4d494e0000000000000000000000000000604082015260600190565b60208082526027908201527f53616665436173743a2076616c756520646f65736e27742066697420696e203160408201527f3238206269747300000000000000000000000000000000000000000000000000606082015260800190565b60208082526021908201527f5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f60408201527f7700000000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526022908201527f546f6b656e7320616e6420616d6f756e7473206c656e677468206d69736d617460408201527f6368000000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526017908201527f4552525f494e4445585f4f55545f4f465f424f554e4453000000000000000000604082015260600190565b60208082526026908201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60408201527f722063616c6c0000000000000000000000000000000000000000000000000000606082015260800190565b60208082526016908201527f4552525f544f4b454e535f414c52454144595f53455400000000000000000000604082015260600190565b6020808252601f908201527f556e6b6e6f776e20616d6f756e7420696e206f6e206669727374207377617000604082015260600190565b6020808252601a908201527f496e73756666696369656e742070726f746f636f6c2066656573000000000000604082015260600190565b60208082526012908201527f4552525f4a4f494e5f41424f56455f4d41580000000000000000000000000000604082015260600190565b60208082526016908201527f43616c6c6572206973206e6f742074686520706f6f6c00000000000000000000604082015260600190565b60208082526011908201527f537761702066656520746f6f2068696768000000000000000000000000000000604082015260600190565b60208082526029908201527f43616c6c65722063616e6e6f74207365742070726f746f636f6c20666c61736860408201527f206c6f616e206665650000000000000000000000000000000000000000000000606082015260800190565b6020808252601b908201527f4552525f544f4b454e535f4c454e4754485f4d5553545f42455f320000000000604082015260600190565b60208082526010908201527f4552525f4449565f494e5445524e414c00000000000000000000000000000000604082015260600190565b6020808252601c908201527f4552525f544f4b454e5f414c52454144595f5245474953544552454400000000604082015260600190565b60208082526023908201527f43616c6c65722063616e6e6f74207365742070726f746f636f6c20737761702060408201527f6665650000000000000000000000000000000000000000000000000000000000606082015260800190565b6020808252818101527f43616c6c65722063616e6e6f74207472616e7366657220617574686f72697479604082015260600190565b60208082526016908201527f506f6f6c20494420616c72656164792065786973747300000000000000000000604082015260600190565b6020808252600f908201527f4552525f4241445f494e44494345530000000000000000000000000000000000604082015260600190565b60208082526013908201527f5377617020666f722073616d6520746f6b656e00000000000000000000000000604082015260600190565b60208082526018908201527f4552525f544f4b454e5f4e4f545f524547495354455245440000000000000000604082015260600190565b60208082526010908201527f4552525f4d554c5f4f564552464c4f5700000000000000000000000000000000604082015260600190565b60208082526015908201527f57697468647261772066656520746f6f20686967680000000000000000000000604082015260600190565b60208082526027908201527f43616c6c65722063616e6e6f74207365742070726f746f636f6c20776974686460408201527f7261772066656500000000000000000000000000000000000000000000000000606082015260800190565b6020808252600c908201527f4552525f4449565f5a45524f0000000000000000000000000000000000000000604082015260600190565b60208082526016908201527f4552525f544f4b454e5f43414e545f42455f5a45524f00000000000000000000604082015260600190565b6020808252601c908201527f4d6973636f6e7374727563746564206d756c7469686f70207377617000000000604082015260600190565b60208082526013908201527f4552525f544f4b454e535f4d49534d4154434800000000000000000000000000604082015260600190565b60208082526016908201527f42414c414e43455f544f54414c5f4f564552464c4f5700000000000000000000604082015260600190565b6020808252601d908201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604082015260600190565b60208082526028908201527f53616665436173743a2076616c756520646f65736e27742066697420696e206160408201527f6e20696e74323536000000000000000000000000000000000000000000000000606082015260800190565b60208082526011908201527f4552525f5355425f554e444552464c4f57000000000000000000000000000000604082015260600190565b60208082526010908201527f4552525f4144445f4f564552464c4f5700000000000000000000000000000000604082015260600190565b60208082526023908201527f4552525f4455455f50524f544f434f4c5f4645455f414d4f554e54535f4c454e60408201527f4754480000000000000000000000000000000000000000000000000000000000606082015260800190565b60208082526024908201527f5369676e6564536166654d6174683a207375627472616374696f6e206f76657260408201527f666c6f7700000000000000000000000000000000000000000000000000000000606082015260800190565b6020808252601e908201527f496e73756666696369656e742062616c616e636520746f20626f72726f770000604082015260600190565b6020808252602a908201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60408201527f6f74207375636365656400000000000000000000000000000000000000000000606082015260800190565b60208082526029908201527f5661756c743a20746f6b656e7320616e6420616d6f756e7473206c656e67746860408201527f206d69736d617463680000000000000000000000000000000000000000000000606082015260800190565b6020808252601f908201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604082015260600190565b60208082526018908201527f53454e4445525f4e4f545f41535345545f4d414e414745520000000000000000604082015260600190565b60006080825261786460808301876166de565b82810360208401526178768187616605565b604084019590955250506060015292915050565b60006060825261789d60608301866166de565b6001600160801b0394851660208401529290931660409091015292915050565b6001600160801b0391909116815260200190565b6001600160801b0392831681529116602082015260400190565b918252602082015260400190565b60405181810167ffffffffffffffff8111828210171561791857600080fd5b604052919050565b600067ffffffffffffffff821115617936578081fd5b5060209081020190565b60005b8381101561795b578181015183820152602001617943565b83811115612ccd5750506000910152565b60e01c90565b600060443d1015617982576104f0565b600481823e6308c379a0617996825161796c565b146179a0576104f0565b6040517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3d016004823e80513d67ffffffffffffffff81602484011181841117156179ee57505050506104f0565b82840192508251915080821115617a0857505050506104f0565b503d83016020828401011115617a20575050506104f0565b601f01601f1916810160200160405291505090565b6001600160a01b0381168114612b0a57600080fd5b8015158114612b0a57600080fdfea2646970667358221220bcbacfc99ae8e94b2fa18b810b6b6666c9403923ffaf20cdaaafd014e4240bcd64736f6c63430007010033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "batchSwapGivenIn(address,bytes,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool))": {
        "details": "Performs a series of swaps with one or multiple Pools. In each swap, the amount of tokens sent to the Pool is known. For swaps where the amount of tokens received from the Pool is known, see `batchSwapGivenOut`. Returns an array with the net Vault token balance deltas. Positive amounts represent tokens sent to the Vault, and negative amounts tokens sent by the Vault. Each delta corresponds to the token at the same index in the `tokens` array. A `validator` can be optionally supplied, and if so it will be called with `tokens`, the Vault deltas, and user-supplied `validatorData`. This is useful to check a swap has happened according to user expectations (and wasn't, for example, affected by other transactions), and potentially revert if not. Each swap is executed independently in the order specified by the `swaps` array. However, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into the User's Internal Balance) after all swaps have been completed and the net token balance change computed. This means it is possible to e.g. under certain conditions perform arbitrage by swapping with multiple Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (but updating the Pool's internal balances). The `swaps` array contains the information about each individual swaps. All swaps consist of a Pool receiving some amount of one of its tokens (`tokenIn`), and sending some amount of another one of its tokens (`tokenOut`). The `tokenOut` amount is determined by the Pool's pricing algorithm by calling the `quoteOutGivenIn` function (from IGeneralPoolQuote or IMinimalSwapInfoPoolQuote). Multihop swaps, where one token is exchanged for another one by passing through one or more intermediate tokens, can be executed by passing an `amountIn` value of zero for a swap. This will cause the amount out of the previous swap to be used as the amount in of the current one. In such a scenario, `tokenIn` must equal the previous swap's `tokenOut`. The `tokens` array contains the addresses of all tokens involved in the swaps. Funds will be sent and  received according to the data in the `funds` struct."
      },
      "batchSwapGivenOut(address,bytes,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool))": {
        "details": "Performs a series of swaps with one or multiple Pools. In each swap, the amount of tokens received from the Pool is known. For swaps where the amount of tokens sent to the Pool is known, see `batchSwapGivenIn`. Returns an array with the net Vault token balance deltas. Positive amounts represent tokens sent to the Vault, and negative amounts tokens sent by the Vault. Each delta corresponds to the token at the same index in the `tokens` array. A `validator` can be optionally supplied, and if so it will be called with `tokens`, the Vault deltas, and user-supplied `validatorData`. This is useful to check a swap has happened according to user expectations (and wasn't, for example, affected by other transactions), and potentially revert if not. Each swap is executed independently in the order specified by the `swaps` array. However, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into the User's Internal Balance) after all swaps have been completed and the net token balance change computed. This means it is possible to e.g. under certain conditions perform arbitrage by swapping with multiple Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (but updating the Pool's internal balances). The `swaps` array contains the information about each individual swaps. All swaps consist of a Pool receiving some amount of one of its tokens (`tokenIn`), and sending some amount of another one of its tokens (`tokenOut`). The `tokenIn` amount is determined by the Pool's pricing algorithm by calling the `quoteInGivenOut` function (from IGeneralPoolQuote or IMinimalSwapInfoPoolQuote). Multihop swaps, where one token is exchanged for another one by passing through one or more intermediate tokens, can be executed by passing an `amountOut` value of zero for a swap. This will cause the amount in of the previous swap to be used as the amount out of the current one. In such a scenario, `tokenOut` must equal the previous swap's `tokenIn`. The `tokens` array contains the addresses of all tokens involved in the swaps. Funds will be sent and  received according to the data in the `funds` struct."
      },
      "changeAuthorizer(address)": {
        "details": "Sets a new Authorizer for the Vault. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canChangeAuthorizer`)."
      },
      "depositToInternalBalance(address[],uint256[],address)": {
        "details": "Deposits tokens from the caller into `user`'s Internal Balance. The caller must have allowed the Vault to use their tokens via `IERC20.approve()`."
      },
      "depositToPoolBalance(bytes32,address,uint256)": {
        "details": "Called by a Pool's Asset Manager for `token` to deposit `amount` tokens into the Vault. This increases the Pool's cash but decreases its managed balance, leaving the total balance unchanged. The Asset Manager must have approved the Vault to use `token`."
      },
      "flashLoan(address,address[],uint256[],bytes)": {
        "details": "Performs a flash loan where 'amount' tokens of 'token' are sent to 'receiver', which must implement the IFlashLoanReceiver interface. An arbitrary user-provided 'receiverData' is forwarded to this contract. Before returning from the IFlashLoanReceiver.receiveFlashLoan call, the receiver must transfer back the loaned tokens, plus a proportional protocol fee."
      },
      "getAuthorizer()": {
        "details": "Returns the Vault's Authorizer."
      },
      "getCollectedFeesByToken(address)": {
        "details": "Returns the amount of protocol fees collected by the Vault for `token`."
      },
      "getInternalBalance(address,address[])": {
        "details": "Returns `user`'s Internal Balance for a specific token."
      },
      "getNumberOfPools()": {
        "details": "Returns the number of Pools."
      },
      "getPool(bytes32)": {
        "details": "Returns a Pool's address and specialization level."
      },
      "getPoolAssetManager(bytes32,address)": {
        "details": "Returns a Pool's Asset Manager for `token`. Asset Managers can manage a Pool's assets by taking them out of the Vault via `withdrawFromPoolBalance`, `depositToPoolBalance` and `updateManagedBalance`."
      },
      "getPoolIds(uint256,uint256)": {
        "details": "Returns a partial list of Pool IDs, starting at index `start`, up to index `end`."
      },
      "getPoolTokenBalanceInfo(bytes32,address)": {
        "details": "Returns the Pool's token cash and managed balances."
      },
      "getPoolTokens(bytes32)": {
        "details": "Returns the Pool's tokens and total balances. This means it will refer also to the assets held by the Pool's Asset Manager and not currently held by the Vault."
      },
      "getProtocolFlashLoanFee()": {
        "details": "Returns the Protocol Flash Loan Fee. These are collected on all Flash Loans. This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee."
      },
      "getProtocolSwapFee()": {
        "details": "Returns the Protocol Swap Fee. These are paid by Pools via `paySwapProtocolFees`. This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee."
      },
      "getProtocolWithdrawFee()": {
        "details": "Returns the Protocol Withdraw Fee. Withdraw fees are applied on `withdraw` and `exitPool` (unless depositing into User's Internal Balance). Swaps and `withdrawFromPoolBalance` are not charged withdraw fees. This is an 18 decimal fixed point number, so e.g. 0.1e18 stands for a 10% fee."
      },
      "joinPool(bytes32,address,address[],uint256[],bool,bytes)": {
        "details": "Called by users to join a Pool, transferring tokens into its balance. The `IPool.onJoinPool` hook will be called on the Pool by the Vault, which will typically grant something to the user in return - often tokenized Pool shares. `maxAmountsIn` is the maximum amount of tokens the user is willing to provide to the Pool, for each token in the `tokens` array. This array must match the Pool's registered tokens. Pools are free to implement any arbitrary logic in the `IPool.onJoinPool` hook, and may require additional information (such as the expected number of Pool shares to obtain). This can be encoded in the `userData` argument, which is ignored by the Vault and passed directly to the Pool, as is `recipient`. If `fromInternalBalance` is true, the caller's Internal Balance will be preferred, performing an ERC20 transfer for the difference between the requested amount and Internal Balance (if any)."
      },
      "queryBatchSwapGivenIn((bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool))": {
        "details": "Simulates a call to batchSwapGivenIn, returning an array of Vault token deltas. Each element in the array corresponds to the token at the same index, and indicates the number of tokens the Vault would take from the caller (if positive) or send to the recipient (if negative). The arguments it receives are the same that an equivalent batchSwapGivenIn would receive. Unlike batchSwapGivenIn, this function performs no checks on its caller nor the recipient field in the FundsManagement struct. This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens, approve them for the Vault, or even know a user's address. Note that this function is not 'view' (due to implementation details): the client code must explicitly execute eth_call instead of eth_sendTransaction."
      },
      "queryBatchSwapGivenOut((bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool))": {
        "details": "Simulates a call to batchSwapGivenOut, returning an array of Vault token deltas. Each element in the array corresponds to the token at the same index, and indicates the number of tokens the Vault would take from the caller (if positive) or send to the recipient (if negative). The arguments it receives are the same that an equivalent batchSwapGivenOut would receive. Unlike batchSwapGivenOut, this function performs no checks on its caller nor the recipient field in the FundsManagement struct. This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens, approve them for the Vault, or even know a user's address. Note that this function is not 'view' (due to implementation details): the client code must explicitly execute eth_call instead of eth_sendTransaction."
      },
      "queryBatchSwapHelper((bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,bool),uint8)": {
        "details": "Despite this function being external, it can only be called by the Vault itself, and should not be considered part of the Vault's external API. It executes the Pool interaction part of a batch swap, asking Pools for quotes and computing the Vault deltas, but without performing any token transfers. It then reverts unconditionally, returning the Vault deltas array as the revert data. This enables an accurate implementation of queryBatchSwapGivenIn and queryBatchSwapGivenOut, since the array 'returned' by this function is the result of the exact same computation a swap would perform, including the Pool calls."
      },
      "registerPool(uint8)": {
        "details": "Registers a the caller as a Pool, with selected specialization level. Returns the Pool's ID. Also emits a PoolCreated event."
      },
      "registerTokens(bytes32,address[],address[])": {
        "details": "Called by the Pool to register `tokens`. A Pool can only add and remove liquidity for tokens it has registered, and all swaps with a Pool must involve registered tokens. Each token in `tokens` must not be already registered before this call. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens must be registered at the same time. Also define the asset manager for each token at registration time (can be the zero address, if a token is unmanaged)"
      },
      "setProtocolFlashLoanFee(uint256)": {
        "details": "Sets a new Protocol Flash Loan Fee. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolFlashLoanFee`)."
      },
      "setProtocolSwapFee(uint256)": {
        "details": "Sets a new Protocol Swap Fee. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolSwapFee`)."
      },
      "setProtocolWithdrawFee(uint256)": {
        "details": "Sets a new Protocol Withdraw Fee. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canSetProtocolWithdrawFee`)."
      },
      "transferInternalBalance(address[],uint256[],address)": {
        "details": "Transfers tokens from the caller's Internal Balance, transferring them to `recipient`'s Internal Balance. This does not charge protocol withdrawal fees."
      },
      "unregisterTokens(bytes32,address[])": {
        "details": "Called by the Pool to unregisted `tokens`. This prevents adding and removing liquidity in the future, as well as swaps. Unregistered tokens can be re-registered in the future. Each token in `tokens` must be registered before this call, and have zero balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens must be unregistered at the same time."
      },
      "updateManagedBalance(bytes32,address,uint256)": {
        "details": "Called by a Pool's Asset Manager for `token` to update the external amount. This causes no change on the Pool's cash, but because the managed balance changes, so does the total balance. The external amount can be both increased and decreased by this call."
      },
      "withdrawFromInternalBalance(address[],uint256[],address)": {
        "details": "Withdraws tokens from the caller's Internal Balance, transferring them to `recipient`. This charges protocol withdrawal fees."
      },
      "withdrawFromPoolBalance(bytes32,address,uint256)": {
        "details": "Called by a Pool's Asset Manager for `token` to withdraw `amount` tokens from the Vault. This decreases the Pool's cash but increases its managed balance, leaving the total balance unchanged."
      },
      "withdrawProtocolFees(address[],uint256[],address)": {
        "details": "Withdraws collected protocol fees. Requirements: - the caller must be approved by the authorizer (`IAuthorizer.canWithdrawProtocolFees`) for each token."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 20178,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 11719,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_authorizer",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IAuthorizer)18541"
      },
      {
        "astId": 11793,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_collectedProtocolFees",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_contract(IERC20)1393,t_uint256)"
      },
      {
        "astId": 11795,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_protocolWithdrawFee",
        "offset": 0,
        "slot": "3",
        "type": "t_uint128"
      },
      {
        "astId": 11797,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_protocolSwapFee",
        "offset": 16,
        "slot": "3",
        "type": "t_uint128"
      },
      {
        "astId": 11799,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_protocolFlashLoanFee",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 12309,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_internalTokenBalance",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_contract(IERC20)1393,t_uint128))"
      },
      {
        "astId": 16442,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_generalPoolsBalances",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_bytes32,t_struct(IERC20ToBytes32Map)19862_storage)"
      },
      {
        "astId": 17010,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_minimalSwapInfoPoolsTokens",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_bytes32,t_struct(AddressSet)2234_storage)"
      },
      {
        "astId": 17016,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_minimalSwapInfoPoolsBalances",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_bytes32,t_mapping(t_contract(IERC20)1393,t_bytes32))"
      },
      {
        "astId": 17550,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_poolTwoTokenTokens",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_bytes32,t_struct(TwoTokenTokens)17541_storage)"
      },
      {
        "astId": 17556,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_poolTwoTokenSharedBalances",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_bytes32,t_mapping(t_bytes32,t_struct(TwoTokenSharedBalances)17546_storage))"
      },
      {
        "astId": 12743,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_pools",
        "offset": 0,
        "slot": "11",
        "type": "t_struct(Bytes32Set)2149_storage"
      },
      {
        "astId": 12759,
        "contract": "contracts/vault/Vault.sol:Vault",
        "label": "_poolAssetManagers",
        "offset": 0,
        "slot": "13",
        "type": "t_mapping(t_bytes32,t_mapping(t_contract(IERC20)1393,t_address))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IAuthorizer)18541": {
        "encoding": "inplace",
        "label": "contract IAuthorizer",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)1393": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_contract(IERC20)1393,t_uint128))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(contract IERC20 => uint128))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_contract(IERC20)1393,t_uint128)"
      },
      "t_mapping(t_bytes32,t_mapping(t_bytes32,t_struct(TwoTokenSharedBalances)17546_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(bytes32 => struct TwoTokenPoolsBalance.TwoTokenSharedBalances))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes32,t_struct(TwoTokenSharedBalances)17546_storage)"
      },
      "t_mapping(t_bytes32,t_mapping(t_contract(IERC20)1393,t_address))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(contract IERC20 => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_contract(IERC20)1393,t_address)"
      },
      "t_mapping(t_bytes32,t_mapping(t_contract(IERC20)1393,t_bytes32))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(contract IERC20 => bytes32))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_contract(IERC20)1393,t_bytes32)"
      },
      "t_mapping(t_bytes32,t_struct(AddressSet)2234_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct EnumerableSet.AddressSet)",
        "numberOfBytes": "32",
        "value": "t_struct(AddressSet)2234_storage"
      },
      "t_mapping(t_bytes32,t_struct(IERC20ToBytes32Map)19862_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct EnumerableMap.IERC20ToBytes32Map)",
        "numberOfBytes": "32",
        "value": "t_struct(IERC20ToBytes32Map)19862_storage"
      },
      "t_mapping(t_bytes32,t_struct(TwoTokenSharedBalances)17546_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct TwoTokenPoolsBalance.TwoTokenSharedBalances)",
        "numberOfBytes": "32",
        "value": "t_struct(TwoTokenSharedBalances)17546_storage"
      },
      "t_mapping(t_bytes32,t_struct(TwoTokenTokens)17541_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct TwoTokenPoolsBalance.TwoTokenTokens)",
        "numberOfBytes": "32",
        "value": "t_struct(TwoTokenTokens)17541_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_contract(IERC20)1393,t_address)": {
        "encoding": "mapping",
        "key": "t_contract(IERC20)1393",
        "label": "mapping(contract IERC20 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_contract(IERC20)1393,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_contract(IERC20)1393",
        "label": "mapping(contract IERC20 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_contract(IERC20)1393,t_uint128)": {
        "encoding": "mapping",
        "key": "t_contract(IERC20)1393",
        "label": "mapping(contract IERC20 => uint128)",
        "numberOfBytes": "32",
        "value": "t_uint128"
      },
      "t_mapping(t_contract(IERC20)1393,t_uint256)": {
        "encoding": "mapping",
        "key": "t_contract(IERC20)1393",
        "label": "mapping(contract IERC20 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_struct(MapEntry)19184_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct EnumerableMap.MapEntry)",
        "numberOfBytes": "32",
        "value": "t_struct(MapEntry)19184_storage"
      },
      "t_struct(AddressSet)2234_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.AddressSet",
        "members": [
          {
            "astId": 2233,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_inner",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(Set)1969_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Bytes32Set)2149_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.Bytes32Set",
        "members": [
          {
            "astId": 2148,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_inner",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(Set)1969_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(IERC20ToBytes32Map)19862_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableMap.IERC20ToBytes32Map",
        "members": [
          {
            "astId": 19861,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_inner",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(Map)19195_storage"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(Map)19195_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableMap.Map",
        "members": [
          {
            "astId": 19186,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_length",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 19190,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_entries",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_struct(MapEntry)19184_storage)"
          },
          {
            "astId": 19194,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_indexes",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_bytes32,t_uint256)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(MapEntry)19184_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableMap.MapEntry",
        "members": [
          {
            "astId": 19181,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_key",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 19183,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_value",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Set)1969_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.Set",
        "members": [
          {
            "astId": 1964,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_values",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_bytes32)dyn_storage"
          },
          {
            "astId": 1968,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "_indexes",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_bytes32,t_uint256)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TwoTokenSharedBalances)17546_storage": {
        "encoding": "inplace",
        "label": "struct TwoTokenPoolsBalance.TwoTokenSharedBalances",
        "members": [
          {
            "astId": 17543,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "sharedCash",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 17545,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "sharedManaged",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(TwoTokenTokens)17541_storage": {
        "encoding": "inplace",
        "label": "struct TwoTokenPoolsBalance.TwoTokenTokens",
        "members": [
          {
            "astId": 17538,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "tokenA",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(IERC20)1393"
          },
          {
            "astId": 17540,
            "contract": "contracts/vault/Vault.sol:Vault",
            "label": "tokenB",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IERC20)1393"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}